<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[手写Android序列化框架FastJson（简易版）]]></title>
    <url>%2Farchives%2F2018%2F06%2F22%2F%E6%89%8B%E5%86%99Android%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6FastJson%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开篇废话近期利用业余时间，跟着大神把FastJson的框架学习了一下，在这里，记录一下这次学习的心得。FastJson是一个Json处理工具包，包括“序列化”和“反序列化”两部分。这次学习 ，大概有以下这些知识点： 1.反射的使用 2.设计模式之责任链的实践 3.泛型以及泛型与反射的结合实践 4.序列化以及反序列化的实现 技术详情1. 反射JAVA反射机制提供了运行时动态编程的可能。当类处于运行状态时，我们可以做如下这些事： 1.获得这个类的所有属性，方法以及注解等信息 2.可以调用这个类的任意属性与方法 下面举一个例子来说明。 public class Book { private int page; private String name; public List&lt;String&gt; authors; public List&lt;? super Integer&gt; wildcardTypeDatas ; public Book(){ } public int getPage() { return page; } public void setPage(int page) { this.page = page; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;String&gt; getAuthors() { return authors; } public void setAuthors(List&lt;String&gt; authors) { this.authors = authors; } } 有一个父类如上，子类如下： public class ComputerBook extends Book { private int codeLine; public ComputerBook(){ } public int getCodeLine() { return codeLine; } public void setCodeLine(int codeLine) { this.codeLine = codeLine; } } 执行下面这段反射的代码： public void test(){ Class&lt;ComputerBook&gt; bookClass = ComputerBook.class; //获得类以及父类中所有声明为public的属性 System.out.println(&quot;所有public属性:&quot;); for (Field field : bookClass.getFields()) { System.out.println(field.getName()); } //获得类(不包括父类)中所有的属性 System.out.println(&quot;所有属性:&quot;); for (Field field : bookClass.getDeclaredFields()) { System.out.println(field.getName()); } //获得类以及父类中所有声明为public的函数 System.out.println(&quot;所有public函数:&quot;); for (Method method : bookClass.getMethods()) { String methodName = method.getName(); System.out.println(methodName); } //获得类(不包括父类)中所有的函数 System.out.println(&quot;所有函数:&quot;); for (Method method : bookClass.getDeclaredMethods()) { String methodName = method.getName(); System.out.println(methodName); } } 获得的结果为： 所有public属性: authors wildcardTypeDatas 所有属性: codeLine 所有public函数: getCodeLine setCodeLine getName setName getPage setPage getAuthors setAuthors wait wait wait equals toString hashCode getClass notify notifyAll 所有函数: getCodeLine setCodeLine 从以上的这个例子，能得知： 1.getDeclaredXX :会获得当前Class中的所有内容 2.getXX: 获得当前类以及父类的内容，但是不包括非public 类中的属性对应反射中的Field，而函数则为Method。但是获取构造方法，则需要通过Constructor: Constructor&lt;?&gt;[] constructors = bookClass.getConstructors(); 操作属性、调用函数的方法则需要编写: try { ComputerBook cb = bookClass.newInstance();//相当于实例化一个对象 Method method = bookClass.getDeclaredMethods()[0]; //在obj对象上调用函数 if(method.getParameters().length == 1) { method.invoke(cb, 1); }else{ Object object = method.invoke(cb, null); System.out.println((Integer) object); } Field field = bookClass.getDeclaredFields()[0]; //对于非public的field或者method,需要先设置这个参数为true field.setAccessible(true); //获得obj中的属性 Object value1 = field.get(cb); System.out.println(value1); //设置obj中的属性 field.set(cb,2); Object value2 = field.get(cb); System.out.println(value2); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } 2. 带泛型的反射首先，应该知道是，带泛型的在运行阶段是会被擦除的，也就是List 与 List在运行阶段，都是List.class,因此，如果，我们需要获得参数类型的具体泛型类型，就需要利用Type接口了 如果我们要获取一个List authors集合的泛型类型，我们应该按下面这种方式来获取： try { Field list = Book.class.getField(&quot;authors&quot;); //判断list是否为List集合类型 if(List.class.isAssignableFrom(list.getType())){ Type genericType = list.getGenericType();//获取属性声明时的类型 //如果是属于参数化类型例如List&lt;String&gt; if(genericType instanceof ParameterizedType){ //获取泛型类型，这里的0代表第一个参数：String Type type = ((ParameterizedType)genericType).getActualTypeArguments()[0]; System.out.println(&quot;获得泛型类型:&quot; + type); } } } catch (NoSuchFieldException e) { e.printStackTrace(); } 另外，泛型中，还有可能存在通配符，例如这种形式的: List&lt;? extends Book&gt; list (存在上边界)或者 List&lt;? super Integer&gt; list（存在下边界），这个时候，我们就需要通过判断是否属于通配符参数类型来处理，例如： List&lt;? super Integer&gt; wildcardTypeDatas,那么，修改上面那段代码如下： try { Field list = Book.class.getField(&quot;wildcardTypeDatas&quot;); //判断list是否为List集合类型 if(List.class.isAssignableFrom(list.getType())){ Type genericType = list.getGenericType();//获取属性声明时的类型 //如果是属于参数化类型例如List&lt;String&gt; if(genericType instanceof ParameterizedType){ //获取泛型类型，这里的0代表第一个参数：String Type type = ((ParameterizedType)genericType).getActualTypeArguments()[0]; //判断是否使用了通配符 if(type instanceof WildcardType){ WildcardType wildcardType = (WildcardType) type; Type[] upperBounds = wildcardType.getUpperBounds(); Type[] lowerBounds = wildcardType.getLowerBounds(); if(upperBounds.length == 1){ Type actualTypeArgument = upperBounds[0]; System.out.println(&quot;获得泛型上边界类型:&quot; + actualTypeArgument); } if(lowerBounds.length == 1){ Type actualTypeArgument = lowerBounds[0]; System.out.println(&quot;获得泛型下边界类型:&quot; + actualTypeArgument); } }else { System.out.println(&quot;获得泛型类型:&quot; + type); } } } } catch (NoSuchFieldException e) { e.printStackTrace(); } 3. 序列化的实现对于反射有了一定了解后，就可以开始接下来的序列化的工作了，序列化的工作，主要有两步 第一步：获取需要序列化的（&quot;key&quot;: &quot;value&quot;）的成员 第二步：根据获得的信息，拼接json字符串 为实现第一步，需要使用到上面介绍的反射技术，先获得 第一步，需要序列化的数据收集（使用递归） /** * 获得对于class包括父class所有的成员属性 * * @param clazz * @return */ public static Map&lt;String, Field&gt; parserAllFieldToCache(Map&lt;String, Field&gt; fieldCacheMap, Class&lt;?&gt; clazz) { //获得自己的所有属性 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { String fieldName = field.getName(); if (!fieldCacheMap.containsKey(fieldName)) { fieldCacheMap.put(fieldName, field); } } //查找父类 的属性 if (clazz.getSuperclass() != null &amp;&amp; clazz.getSuperclass() != Object.class) { parserAllFieldToCache(fieldCacheMap, clazz.getSuperclass()); } return fieldCacheMap; } 然后根据类中以及父类中所有的属性，来获取需要序列化的成员， /** * 获得需要序列化的成员 * 包括: 当前类与父类的get函数、public成员属性 * * @param clazz */ public static List&lt;FieldSerializer&gt; computeGetters(Class&lt;?&gt; clazz, Map&lt;String, Field&gt; fieldCacheMap) { Map&lt;String, FieldInfo&gt; fieldInfoMap = new LinkedHashMap&lt;&gt;(); //类(父类) 所有的公有函数 Method[] methods = clazz.getMethods(); for (Method method : methods) { String methodName = method.getName(); //不要static if (Modifier.isStatic(method.getModifiers())) { continue; } //不要返回值是void if (method.getReturnType().equals(Void.TYPE)) { continue; } //不要参数 if (method.getParameterTypes().length != 0) { continue; } // 不要getClass if (methodName.equals(&quot;getClass&quot;)) { continue; } String propertyName; // getA if (methodName.startsWith(&quot;get&quot;)) { //必须4个或者4个字符以上的函数名 if (methodName.length() &lt; 4) { continue; } //get后的第一个字母 char c3 = methodName.charAt(3); // A-&gt; age propertyName = Character.toLowerCase(c3) + methodName.substring(4); //可能拿到null Field field = fieldCacheMap.get(propertyName); FieldInfo fieldInfo = new FieldInfo(propertyName, method, field); fieldInfoMap.put(propertyName, fieldInfo); } if (methodName.startsWith(&quot;is&quot;)) { if (methodName.length() &lt; 3) { continue; } //不是boolean或者Boolean if (method.getReturnType() != Boolean.TYPE &amp;&amp; method.getReturnType() != Boolean.class) { continue; } char c2 = methodName.charAt(2); propertyName = Character.toLowerCase(c2) + methodName.substring(3); //可能已经在get找到了 if (fieldInfoMap.containsKey(propertyName)) { continue; } Field field = fieldCacheMap.get(propertyName); FieldInfo fieldInfo = new FieldInfo(propertyName, method, field); fieldInfoMap.put(propertyName, fieldInfo); } } //所有的公有成员 Field[] fields = clazz.getFields(); for (Field field : fields) { //静态的不要 if (Modifier.isStatic(field.getModifiers())) { continue; } String propertyName = field.getName(); //把公有成员也加入json if (!fieldInfoMap.containsKey(propertyName)) { FieldInfo fieldInfo = new FieldInfo(propertyName, null, field); fieldInfoMap.put(propertyName, fieldInfo); } } // List&lt;FieldSerializer&gt; fieldInfos = new ArrayList&lt;&gt;(); //fieldinfo加入到list集合中 for (FieldInfo fieldInfo : fieldInfoMap.values()) { fieldInfos.add(new FieldSerializer(fieldInfo)); } return fieldInfos; } 第二步，就是拼接json字符串了，按照json的语法，按照(key,value)的形式拼接起来： public void serializer(SerializerContext context,JsonConfig config, StringBuilder out, Object object) { //{&quot;age&quot;:100,&quot;name&quot;:&quot;testname&quot;,&quot;test&quot;:1,&quot;list&quot;:[&quot;1&quot;,&quot;2&quot;]} out.append(&quot;{&quot;); boolean lastEmpty = false; for(FieldSerializer fieldSerializer : fieldSerializers){ //&quot;name&quot;:&quot;testname&quot; 、 &quot;age&quot;:100 // 如果遇到属性没有值 (null) 则返回 &quot;&quot; String serializer = fieldSerializer.serializer(context != null ?context : new SerializerContext(),config,object); if(lastEmpty &amp;&amp; !serializer.isEmpty()){ out.append(&quot;,&quot;); } if(!lastEmpty){ lastEmpty = !serializer.isEmpty(); } out.append(serializer); } out.append(&quot;}&quot;); } 由于，类中的属性可能是基本数据类型，String,List,Map,或者Javabean等类型，所以，就需要针对不同的类型进行，这里就使用了责任链模式，根据不同类型，交由不同的序列化器进行序列化： public String serializer(SerializerContext serializerContext,JsonConfig config, Object object) { Object o = fieldInfo.get(object); //属性没有值 if (null == o) { return &quot;&quot;; } StringBuilder sb = new StringBuilder(); if (isPrimitive) { sb.append(key); sb.append(o); } else if (Utils.isString(fieldInfo.type)) { sb.append(key); sb.append(&quot;\&quot;&quot;); sb.append(o); sb.append(&quot;\&quot;&quot;); } else { //JavaBean List if(serializerContext.refrence.containsKey(key) &amp;&amp; serializerContext.refrence.get(key) == object){ return sb.toString(); } serializerContext.refrence.put(key,object); ObjectSerializer serializer = config.getSerializer(fieldInfo.type); sb.append(key); serializer.serializer(serializerContext,config, sb, o); } return sb.toString(); } 通过调用JsonConfig中的getSerializer来获取相应的序列化器： public ObjectSerializer getSerializer(Class&lt;?&gt; clazz){ ObjectSerializer objectSerializer = serializers.get(clazz); if(null != objectSerializer){ return objectSerializer; } if(List.class.isAssignableFrom(clazz)){ objectSerializer = ListSerializer.instance; }else if(Map.class.isAssignableFrom(clazz)){ throw new RuntimeException(&quot;Map序列化未实现&quot;); }else if(clazz.isArray()){ throw new RuntimeException(&quot;数组序列化未实现&quot;); }else{ objectSerializer = new JavaBeanSerializer(clazz); } serializers.put(clazz,objectSerializer); return objectSerializer; } 4. 反序列化的实现反序列化的设计与序列化差不多，也是先收集反序列化的成员，然后通过反射设置实例化对象的值 第一步，收集反序列化成员，和序列化一样 第二步，通过反射实例化对象，并设置对应的值 public &lt;T&gt; T deserializer(JsonConfig config, String json, Object object) throws Throwable { //JSONObject jsonObject = new JSONObject(json); JSONObject jsonObject = null; if(null == object){ jsonObject = new JSONObject(json); }else{ jsonObject = (JSONObject) object; } T t = null; try{ t = (T) beanType.newInstance(); }catch (Exception e){ e.printStackTrace(); } //{&quot;age&quot;:100,&quot;name&quot;:&quot;testname&quot;,&quot;test&quot;:1,&quot;list&quot;:[&quot;1&quot;,&quot;2&quot;]} for(FieldInfo fieldInfo : fieldInfos){ //json数据中没有对应的key if(!jsonObject.has(fieldInfo.name)){ continue; } Object value = jsonObject.get(fieldInfo.name); if(value instanceof JSONObject || value instanceof JSONArray){ ObjectDeserializer deserializer = config.getDeserializer(fieldInfo.genericType); Object obj = deserializer.deserializer(config,null,value); fieldInfo.set(t,obj); }else{ if(value != JSONObject.NULL){ fieldInfo.set(t,value); } } } return t; } 以下是此项目的简书地址： SenduoJson]]></content>
      <categories>
        <category>Android框架之旅</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FastJson</tag>
        <tag>责任链</tag>
        <tag>json</tag>
        <tag>序列化</tag>
        <tag>反序列化</tag>
        <tag>反射</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟OkHttp框架，手写简易网络访问框架]]></title>
    <url>%2Farchives%2F2018%2F05%2F06%2F%E6%A8%A1%E6%8B%9FOkHttp%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[开篇废话趁着周末两天的时间，跟着大神的脚步，把我们经常使用的网络框架OkHttp的源码好好跟了一下，初次观看，确实非常容易钻进去，搞得云里雾里，在大神的指导下，才勉强把整个逻辑走通。写这篇文章，也是希望自己脑袋里面，能对这个网络框架有一个整体的认识，了解它整体设计思想。 大概了解后，还是需要自己亲自动手，来手写当中的一些细节，加深自己理解，所以，接下来，我会给出OkHttp中设计的主线，以及模拟OkHttp，手写一个属于我们自己的网络框架。 废话就到此为止了，开始这次的学习之旅吧。。。 技术详情1. OkHttp 的主线调用关于OkHttp的使用，我这里就不说了，不清楚的可以，在简书里面搜索一下，应该有非常多文章来说明，我这里就大概说一下调用的主线流程。 第一步：使用者拿到OkHttpClient对象，一般我们都会声明成全局的一个对象 第二步：使用OkHttpClient对象来拿到一个RealCall对象 第三步：用这个对象，把我们的Request请求（请求包含一些服务器信息）加入到它的一个调度器 这个调度器是通过控制执行/等待队列的线程池来调度我们传进去的网络请求 第四步：执行RealCall中网络请求，将请求结果返回给我们使用者，这一步中，OkHttp框架会帮我 做很多优化处理，其中的责任链式的拦截器，就在这个步骤中实现 查看如下的图片，可能更清晰点， OkHttp中拦截器的整体调用逻辑，可以查看下面这张图，可以说非常清晰了，细节地方，自己可以去查看源码了： 对于当中具体调用细节，我这里就不再讲述了，可以根据手写的简易OkHttp框架来对它们有一个整体的认识。 2. 模拟OkHttp,手写简易Http框架对OkHttp的设计思路有一个整体的认识后，自己手写一个简易版的Http框架，加深一下对OkHttp源码的认识。手写Http框架，当中能够学到以下知识点： 1.对于http协议能够有熟悉的认识 2.线程池的项目实践 3.建造者模式的项目实践 4.socket层的字节流处理 5.责任链模式的项目实践，熟悉OkHttp中的责任链模式的拦截器 首先，根据使用者习惯，完成HttpClient的功能（建造者模式）: public class HttpClient { //设置调度器 private Dispather dispather; //声明拦截器 private List&lt;Interceptor&gt; interceptors; //尝试次数 private int retryTimes; //连接池 private ConnectionPool connectionPool; public int getRetryTimes() { return retryTimes; } public Dispather getDispather() { return dispather; } public List&lt;Interceptor&gt; getInterceptors() { return interceptors; } public ConnectionPool getConnectionPool() { return connectionPool; } /** * 构造方法 */ public HttpClient(Builder builder){ this.dispather = builder.dispather; this.interceptors = builder.interceptors; this.retryTimes = builder.retryTimes; this.connectionPool = builder.connectionPool; } /** * 生成一个网络请求Call对象实例 * @param request * @return */ public Call newCall(Request request){ return new Call(this,request); } //TODO 建造对象 public static final class Builder{ Dispather dispather; List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); int retryTimes; ConnectionPool connectionPool; public Builder addInterceptors(Interceptor interceptor){ interceptors.add(interceptor); return this; } public Builder setDispather(Dispather dispather){ this.dispather = dispather; return this; } public Builder setRetryTimes(int retryTimes){ this.retryTimes = retryTimes; return this; } public Builder setConnectionPool(ConnectionPool connectionPool){ this.connectionPool = connectionPool; return this; } public HttpClient build(){ if(null == dispather){ dispather = new Dispather(); } if(null == connectionPool){ connectionPool = new ConnectionPool(); } return new HttpClient(this); } } } 使用者能够通过设置失败重试次数，自定义拦截器构造一个httpClient对象 得到HttpClient对象后，就能拿到Call对象了，以下是Call里面的实现： public class Call { private HttpClient httpClient; private Request request; public Request getRequest() { return request; } public HttpClient getHttpClient() { return httpClient; } //TODO 是否被执行过 boolean executed; //TODO 是否被取消了 boolean canceled; public boolean isCanceled() { return canceled; } public Call(HttpClient httpClient, Request request){ this.httpClient = httpClient; this.request = request; } /** * 获取返回 * @return * @throws IOException */ Response getResponse() throws IOException{ ArrayList&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(httpClient.getInterceptors()); interceptors.add(new RetryInterceptor()); interceptors.add(new HeadersInterceptor()); interceptors.add(new ConnectionInterceptor()); interceptors.add(new CallServiceInterceptor()); InterceptorChain interceptorChain = new InterceptorChain(interceptors,0,this,null); Response response = interceptorChain.proceed(); return response; } /** * 将Call对象放到调度器里面去执行，如果已经加过了，就不能加了 * @param callback * @return */ public Call enqueue(Callback callback){ synchronized (this){ if(executed){ throw new IllegalStateException(&quot;This Call Already Executed!&quot;); } executed = true; } httpClient.getDispather().enqueue(new AsyncCall(callback)); return this; } final class AsyncCall implements Runnable{ private Callback callback; public AsyncCall(Callback callback){ this.callback = callback; } @Override public void run() { boolean signalledCallback = false; try { Response response = getResponse(); if(canceled){ signalledCallback = true; callback.onFailure(Call.this,new IOException(&quot;this task had canceled&quot;)); }else{ signalledCallback = true; callback.onResponse(Call.this,response); } } catch (IOException e) { if(!signalledCallback){ callback.onFailure(Call.this,e); } } finally { //将这个任务从调度器移除 httpClient.getDispather().finished(this); } } public String getHost(){ return request.getHttpUrl().getHost(); } } } Call类中的AsyncCall线程，是请求真正开始的地方，使用者调用enqueue的时候，只是把这个AsyncCall线程添加到调度器Dispather的线程池，其中，Dispacher中的实现如下： public class Dispather { //TODO 最多同时请求的数量 private int maxRequests; //TODO 同一个host最多允许请求的数量 private int maxRequestPreHost; public Dispather(){ this(64,5); } public Dispather(int maxRequests,int maxRequestPreHost){ this.maxRequestPreHost = maxRequestPreHost; this.maxRequests = maxRequests; } private ExecutorService executorService;//声明一个线程池 //TODO 等待双端队列，双端比较适合增加与删除 private final Deque&lt;Call.AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); //TODO 运行中的双端队列 private final Deque&lt;Call.AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** * 线程池的初始化 * @return */ public synchronized ExecutorService initExecutorService(){ if(null == executorService){ //这里只是给这个线程起一个名字 ThreadFactory threadFactory = new ThreadFactory() { @Override public Thread newThread(@NonNull Runnable runnable) { Thread thread = new Thread(runnable,&quot;Http Client Thread&quot;); return thread; } }; //这里按照OkHttp的线程池样式来创建，单个线程在闲置的时候保留60秒 executorService = new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;(),threadFactory); } return executorService; } /** * 将线程加入到线程池队列 * @param asyncCall */ public void enqueue(Call.AsyncCall asyncCall){ Log.e(&quot;Dispatcher&quot;, &quot;同时有:&quot; + runningAsyncCalls.size()); Log.e(&quot;Dispatcher&quot;, &quot;host同时有:&quot; + getRunningPreHostCount(asyncCall)); //TODO 首先判断正在运行的队列是否已经满了，而且同一个host请求的是否已经超过规定的数量 if(runningAsyncCalls.size() &lt; maxRequests &amp;&amp; getRunningPreHostCount(asyncCall) &lt; maxRequestPreHost){ Log.e(&quot;Dispatcher&quot;, &quot;提交执行&quot;); runningAsyncCalls.add(asyncCall); initExecutorService().execute(asyncCall); }else{ //不满足条件，就加到等待队列 Log.e(&quot;Dispatcher&quot;, &quot;等待执行&quot;); readyAsyncCalls.add(asyncCall); } } /** * 获取同一host在正在运行队列中的数量 * @param asyncCall * @return */ private int getRunningPreHostCount(Call.AsyncCall asyncCall) { int count = 0; for(Call.AsyncCall runningAsyncCall : runningAsyncCalls){ if(runningAsyncCall.getHost().equals(asyncCall.getHost())){ count ++; } } return count; } public void finished(Call.AsyncCall asyncCall){ synchronized (this){ runningAsyncCalls.remove(asyncCall); checkReadyCalls(); } } /** * 检查是否可以运行等待中的请求 */ private void checkReadyCalls() { //达到了同时请求最大数 if(runningAsyncCalls.size() &gt;= maxRequests){ return; } //没有等待执行的任务 if(readyAsyncCalls.isEmpty()){ return; } Iterator&lt;Call.AsyncCall&gt; asyncCallIterator = readyAsyncCalls.iterator(); while(asyncCallIterator.hasNext()){ Call.AsyncCall asyncCall = asyncCallIterator.next(); //如果获得的等待执行的任务 执行后 小于host相同最大允许数 就可以去执行 if(getRunningPreHostCount(asyncCall) &lt; maxRequestPreHost){ asyncCallIterator.remove(); runningAsyncCalls.add(asyncCall); executorService.execute(asyncCall); } if(runningAsyncCalls.size() &gt;= maxRequests){ return; } } } } 调度器中只是负责把添加进来的请求进行按序执行管理，真正执行，还是在AsyncCall线程中run方法，其中的责任链式的拦截器，也在这里面进行添加，执行。我这里自己手写的拦截器，没有像OkHttp那么全而细，知道它的设计思想后，自己只是手动实现一个简单的责任链拦截器，其中包括 1.重试拦截器 2.Http头拦截器 3.选择有效socket连接的拦截器 4.socket通信拦截器 这个顺序是不能随意调换的，就跟工厂里面的流水线一样，一步一步往下走的。首先，实现的是重试拦截器 public class RetryInterceptor implements Interceptor { @Override public Response intercept(InterceptorChain interceptorChain) throws IOException { Log.e(&quot;interceprot&quot;, &quot;重试拦截器....&quot;); Call call = interceptorChain.call; IOException ioException = null; for(int i = 0 ; i &lt; call.getHttpClient().getRetryTimes(); i ++){ if(call.isCanceled()){ throw new IOException(&quot;this task had canceled&quot;); } try { Response response = interceptorChain.proceed(); return response; }catch (IOException e){ ioException = e; } } throw ioException; } } 然后是Http头处理的拦截器 public class HeadersInterceptor implements Interceptor { @Override public Response intercept(InterceptorChain interceptorChain) throws IOException { Log.e(&quot;interceprot&quot;,&quot;Http头拦截器....&quot;); Request request = interceptorChain.call.getRequest(); Map&lt;String,String&gt; headers = request.getHeaders(); if(!headers.containsKey(HttpCodec.HEAD_HOST)){ headers.put(HttpCodec.HEAD_HOST,request.getHttpUrl().getHost()); } if(!headers.containsKey(HttpCodec.HEAD_CONNECTION)) { headers.put(HttpCodec.HEAD_CONNECTION, HttpCodec.HEAD_VALUE_KEEP_ALIVE); } if(null != request.getRequestBody()){ String contentType = request.getRequestBody().getContentType(); if(null != contentType){ headers.put(HttpCodec.HEAD_CONTENT_TYPE,contentType); } long contentLength = request.getRequestBody().getContentLength(); if(-1 != contentLength){ headers.put(HttpCodec.HEAD_CONTENT_LENGTH,Long.toString(contentLength)); } } return interceptorChain.proceed(); } } 接着是选择可用socket连接的拦截器 public class ConnectionInterceptor implements Interceptor { @Override public Response intercept(InterceptorChain interceptorChain) throws IOException { Log.e(&quot;interceptor&quot;, &quot;获取连接拦截器&quot;); Request request = interceptorChain.call.getRequest(); HttpClient httpClient = interceptorChain.call.getHttpClient(); HttpUrl httpUrl = request.getHttpUrl(); HttpConnection httpConnection = httpClient.getConnectionPool().getHttpConnection(httpUrl.getHost(),httpUrl.getPort()); if(null == httpConnection){ httpConnection = new HttpConnection(); }else{ Log.e(&quot;interceptor&quot;, &quot;从连接池中获得连接&quot;); } httpConnection.setRequest(request); try { Response response = interceptorChain.proceed(httpConnection); if (response.isKeepAlive()){ httpClient.getConnectionPool().putHttpConnection(httpConnection); }else{ httpConnection.close(); } return response; }catch (IOException e){ httpConnection.close(); throw e; } } } 把请求的配置信息都配置好后，最后，交给socket去通信，去解析，就是socket通信拦截器了： public class CallServiceInterceptor implements Interceptor { @Override public Response intercept(InterceptorChain interceptorChain) throws IOException { Log.e(&quot;interceptor&quot;, &quot;通信拦截器&quot;); HttpConnection httpConnection = interceptorChain.httpConnection; HttpCodec httpCodec = new HttpCodec(); InputStream inputStream = httpConnection.call(httpCodec); //获取服务器返回的响应行 HTTP/1.1 200 OK\r\n String statusLine = httpCodec.readLine(inputStream); //获取服务器返回的响应头 Map&lt;String,String&gt; headers = httpCodec.readHeaders(inputStream); //根据Content-Length或者Transfer-Encoding(分块)计算响应体的长度 int contentLength = -1; if(headers.containsKey(HttpCodec.HEAD_CONTENT_LENGTH)){ contentLength = Integer.valueOf(headers.get(HttpCodec.HEAD_CONTENT_LENGTH)); } //是否为分块编码 boolean isChunked = false; if(headers.containsKey(HttpCodec.HEAD_TRANSFER_ENCODING)){ isChunked = headers.get(HttpCodec.HEAD_TRANSFER_ENCODING).equalsIgnoreCase(HttpCodec.HEAD_VALUE_CHUNKED); } //获取服务器响应体 String body = null; if(contentLength &gt; 0){ byte[] bodyBytes = httpCodec.readBytes(inputStream,contentLength); body = new String(bodyBytes,HttpCodec.ENCODE); }else if(isChunked){ body = httpCodec.readChunked(inputStream,contentLength); } // HTTP/1.1 200 OK\r\n status[0] = &quot;HTTP/1.1&quot;,status[1] = &quot;200&quot;,status[2] = &quot;OK\r\n&quot; String[] status = statusLine.split(&quot; &quot;); //根据响应头中的Connection的值，来判断是否能够复用连接 boolean isKeepAlive = false; if(headers.containsKey(HttpCodec.HEAD_CONNECTION)){ isKeepAlive = headers.get(HttpCodec.HEAD_CONNECTION).equalsIgnoreCase(HttpCodec.HEAD_VALUE_KEEP_ALIVE); } //更新此请求的最新使用时间，作用于线程池的清理工作 httpConnection.updateLastUseTime(); return new Response(Integer.valueOf(status[1]),contentLength,headers,body,isKeepAlive); } } 经过以上四个拦截器后，使用者就能够正常使用http或者https的请求了。这里面还有一些额外处理的类，我这里就没有给出来了，具体的可以去我的github上查看项目源码，注释写了蛮多，应该很好理解。 关于此项目的源代码，在文章最后，会提供github地址，欢迎star 干货总结阅读框架源码，说真的，确实是一件非常蛋疼的事，但是为了提升自己，却不得不去啃这个硬骨头，学习他人优秀的设计思想为己所用。只有积累的足够多方法之后，我们才能真正得去创造。 对于我们项目中框架的使用，会引入很多不一样的框架，比如retrofit（okhttp）,glide,greenDao数据库框架,arouter路由框架，rxjava,butterknife,以及一些其他的第三方自定义控件等，就会不知不觉是我们的项目越发的庞大，而且比较难以维护，所以，建议我们自己项目，能够尽量自己手写相关的框架，而不要直接引用别人的（我个人的愿景，不喜勿喷）。 希望通过此文章以及源码，能够学习到以下知识点，也不枉我码了那么多字： 1.对于http协议能够有熟悉的认识 2.线程池的项目实践 3.建造者模式的项目实践 4.socket层的字节流处理 5.责任链模式的项目实践，熟悉OkHttp中的责任链模式的拦截器 接下来的日子，希望能够对数据库框架，路由框架，图片加载框架，换肤框架，热更新框架等框架，进行熟悉，然后给出自己手写的简易版本，提升自身对于这些框架的认识。 以下是此项目的源码： SenduoHttp]]></content>
      <categories>
        <category>Android框架之旅</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>责任链</tag>
        <tag>OkHttp</tag>
        <tag>建造者模式</tag>
        <tag>socket</tag>
        <tag>http</tag>
        <tag>https</tag>
        <tag>线程池，拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础知识回顾之Fragment]]></title>
    <url>%2Farchives%2F2017%2F08%2F26%2FAndroid%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B9%8BFragment%2F</url>
    <content type="text"><![CDATA[开篇废话公司搬迁告一段落，吐槽一句，从此就需要过上车程一个半小时的上下班之旅了。。。。。。 上一篇我们了解了四大组件之一的Activity,应该对于Activity有了一定的了解，这一篇文章，我们一起来回顾一下我们依然比较熟悉的Fragment。 首先，我们要知道，在Android3.0以前，是没有Fragment这个的，但为了让大屏幕设备的UI更合理，更灵活，所以在Android3.0的时候，就出现了Fragment。而我们实际开发中更喜欢使用Fragment来替代之前的Activity的切换，主要是因为，Fragment进行切换更加的节省内存，同时，UI切换的时候，给用户的体验会更加的舒服。 那么， 接下来，我们一起来详细的回顾一下我们实际开发中所遇到的Fragment的相关知识。 技术详情本次回顾Fragment，准备按如下逻辑进行一一讲述： 1. Fragment为什么被称为第“五”大组件？ 2. Fragment的生命周期都有哪些？ 3. Fragment是如何通信的？ 4. Fragment管理器：FragmentManager是怎么管理Fragment的？ 1.Fragment为什么被称为第五大组件？1.Fragment被称为第五大组件的原因众所周知，在我们的Android系统当中，有四大组件：Activity,Service,广播，ContentProvider。 在我们实际开发当中，Fragment使用频率，作用都是非常突出的，所以说，将Fragment列为第五大组件也是可以的。 不过也有不少人把View列为第五大组件，但是View与Fragment有一个比较明显的不同之处，就是View是没有生命周期的，而Fragment是有生命周期的，有了生命周期，Fragment就能与Activity一样进行更灵活的处理。 不过，我们需要注意的是，Fragment并不是像Activity一样，完全独立的，虽然拥有自己的生命周期，但是，Fragment必须依附于Activity,同时还要加载到Activity当中去,接下来讲讲Fragment加载到Activity中的方式有哪些。 2.Fragment加载到Activity的两种方式首先，第一种加载方式，静态加载 把Fragment直接在作为一个xml标签加载到Activity的布局文件中去。下面讲一下实际开发中，我们是怎么使用静态加载的。 首先需要有一个Activity承载Fragment的布局，这个Activity的布局如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;fragment android:id=&quot;@+id/fragment_title&quot; android:name=&quot;senduo.com.studydemo.fragment.TitleFragment&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;50dp&quot; /&gt; &lt;fragment android:layout_below=&quot;@id/fragment_title&quot; android:id=&quot;@+id/fragment_content&quot; android:name=&quot;senduo.com.studydemo.fragment.ContentFragment&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; /&gt; &lt;/RelativeLayout&gt; 这个Activity的java文件ActivityForFragment.java如下（简单例子，不添加任何逻辑业务）： import android.support.v7.app.AppCompatActivity; import android.os.Bundle; public class ActivityForFragment extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_for_fragment); } } 有了承载的Activity之后，就可以手动创建一个Fragment继承自Fragment，我这里用一个TitleFragment和ContentFragment来举例说明， TitleFragment.java文件为： import android.os.Bundle; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import senduo.com.studydemo.R; public class TitleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_title, container, false); } } 对应的布局文件为fragment_title.xml： &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/black&quot; tools:context=&quot;senduo.com.studydemo.fragment.TitleFragment&quot;&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@android:color/white&quot; android:text=&quot;我是标题Fragment&quot; /&gt; &lt;/FrameLayout&gt; ContentFragment.java文件为： import android.os.Bundle; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import senduo.com.studydemo.R; public class ContentFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_content, container, false); } } 对应的布局文件为fragment_content.xml: &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;senduo.com.studydemo.fragment.ContentFragment&quot;&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;我是界面内容Fragment&quot; /&gt; &lt;/FrameLayout&gt; 然后看一下运行之后的效果如下： 第二种加载方式，动态加载 我们实际开发中，用的比较多还是使用动态加载，通过FragmentManager和FragmentTransaction来进行动态创建Fragment。 下面详细介绍一下Fragment的动态创建过程 第一步：创建FragmentManager的对象，然后通过这个对象创建一个FragmentTransaction实例对象 FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); 第二步：调用FragmentTransaction中的add()方法进行添加Fragment的对象 transaction.add(R.id.fragment_content,TitleFragment); 这里需要注意的是，第一个参数传入的不是layout而是Activity中的一个控件的ID，表示Fragment在Activity具体显示在哪里，同时也是在这个FragmentManager队列中的Fragment唯一标识符，在Fragment通信过程中需要用到 第三步：调用FragmentTransaction中的commit()方法，让以上操作进行生效 transaction.commit(); 3.FragmentPagerAdapter 和 FragmentStatePagerAdapter的区别我们实际开发中，使用Fragment，一般都是通过viewpager（左右滑动）控件与Fragment结合进行使用，Fragment用来控制滑动时显示的具体界面，他们之间的结合使用，就会有FragmentPagerAdapter与FragmentStatePagerAdapter的区别。 我们可以有一个简单的概念：当Fragment页面较多的时候，使用FragmentStatePagerAdapter,较少的时候使用FragmentPagerAdapter 而其中的原因，我们主要查看一下FragmentStatePagerAdapter的destroyItem()方法源码： @Override public void destroyItem(ViewGroup container, int position, Object object) { Fragment fragment = (Fragment) object; if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object + &quot; v=&quot; + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) { mSavedState.add(null); } mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); mCurTransaction.remove(fragment); } 可以看到，FragmentStatePagerAdapter的destoryItem() 的方法中的最后一行， mCurTransaction.remove(fragment)，是将这个Fragment实例直接从队列中移除，也就是释放了内存 而FragmentPagerAdapter的destoryItem()方法源码： @Override public void destroyItem(ViewGroup container, int position, Object object) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object + &quot; v=&quot; + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object); } 最后一行是mCurTransaction.detach((Fragment)object)，调用的是detach方法，这个方法只是将Activity的UI与Fragment的UI进行分离，并没有进行回收内存，因此从内存占用角度来说，当页面较少的时候，比较适合使用FragmentPagerAdapter。 2.Fragment的生命周期都有哪些？首先，我们来看一下Fragment独立的一个生命周期： 总的来看，Fragment的生命周期与Activity的生命周期比较相似。之前我们也谈到过，Fragment本身不能独立存在的，必须依附在某一个Activity上，那么，关于Fragment的实际开发中需要了解的生命周期，我们需要结合一下Activity的生命周期来进行认识： 直接看图倒是可以知道整个流程，但是，方法确实太多了，他们之间的区别和联系其实还是没有办法能够搞清楚，一个一个进行讲解恐怕也会比较枯燥，所以，如果真正想弄懂整个过程，还是需要我们平时的日积月累以及深入探究。这里我就大概描述一下这个过程，希望能够帮助大家更好的进行理解： 首先，我们能够看到，当Fragment进行第一次创建的时候，会调用onAttach()方法，表明Fragment与Activity进行关联后进行的回调 onAttach()方法后，会调用Fragment中的onCreate()方法，初次创建Fragment的时候进行回调，区别于Activity的onCreate()方法，这个只是创建Fragment,但Activity并没有创建完成 之后调用的Fragment的onCreateView()方法，表示系统首次绘制Fragment的UI，值得注意的是，从这个方法返回的View必须是Fragment布局的根视图。 之后调用的是onViewCreated()方法，表示Fragment的UI界面已经完全绘制好了，这个时候可以进行初始化Fragment的控件资源 接下来，就是调用Activity的onCreate()方法，表示Activity创建完成的回调 之后，调用的是Fragment的onActivityCreated()方法，表示Activity被渲染，绘制成功以后进行的回调，值得注意的是，这个方法必须在Activity的onCreate()方法之后进行调用 接着调用Activity的onStart()方法，表示Activity已经可见了 之后调用Fragment的onStart()方法，表示Fragment也已经可见了 接着调用Activity的onResume()方法，表示Activity已经可以与用户进行交互了 之后调用Fragment的onResume()方法，表示Fragment也可以与用户进行交互了，可以执行处理点击，滑动之类的行为了，已经完成了Fragment从启动到展现的整个操作。 接下来就是回退之后的生命周期了，先走Fragment的onPause()方法，表示已经不能与用户进行交互了 接着调用Activity的onPause的方法，表示Activity也不能与用户进行交互了 接着调用Fragment的onStop()方法，表示Fragment不可见了 接着调用Activity的onStop()方法，表示Activity不可见了 然后调用onDestoryView()方法，这个方法我们不是很熟悉，但是我们需要知道的是，与这个方法对应的是onCreateView()方法，表示这个Fragment即将结束，然后会被保存。 接着会回调Fragment的onDestory()方法，与之前对应的onCreate()方法，表示Fragment不会被使用。 接着调用Fragment生命周期的最后一个方法，onDetach()方法，表示整个Fragment已经被销毁 最后调用Activity的onDestory()方法，表示整个Activity被回收了。 以上就是一个Fragment从启动到销毁的整个过程，接下来我们来回顾一下Fragment的数据通信。 3. Fragment是如何通信的？关于Fragment的通信，我们需要有以下三个大的概念： 1. 在Fragment中调用Activity中的方法 ----&gt; 使用getActivity() 2. Activity中调用Fragment中的方法 ----&gt; 常用接口回调，在Fragment定义一个接口，在Activity中进行实现该接口 3. Fragment中调用Fragment中的方法 ----&gt; 首先使用getActivity()获取Activity的方法，然后通过findFragmentById获取到另一个Fragment中的方法 这三种方式，我们需要进行理解他们的使用方式，这样，我们遇到需要实现某一个功能的时候，可以借鉴这些方式进行实现，提供最适合的功能实现方案。 4.Fragment管理器：FragmentManager是怎么管理Fragment的在我们实际开发过程当中，都需要将某一个Fragment进行显示，隐藏，替换，移除等相关的操作，我们都是通过FragmentManager的操作类FragmentTransaction对象进行操作的。主要有以下这些方法： 1. add:将新创建的一个Fragment实例加入到FragmentManager的队列中去，切换的时候，Fragment的状态信息或者成员变量都没有发生改变 2. replace：将之前显示的Fragment直接remove销毁掉，然后再把当前的Fragment add进来，也就是需要移除之前的Fragment再重新创建一个新的Fragment实例 3. remove：移除，销毁FragmentManager队列中的Fragment 4. hide:将某一个Fragment实例进行隐藏，但状态信息以及成员变量都没有进行回收 5. show:将某一个Fragment实例进行显示 6. detach：并不是将某一个Fragment实例进行销毁，而是将Fragment的View进行销毁，下次再加载的时候，需要重新绘制View 7. attach: 与detach方法相对应，将之前销毁View的Fragment的实例进行重新绘制View,在实际开发中，这一对我们用的相对比较少，因为论速度，并没有hide/show方式那么快，论占用内存的多少，也没有比add/remove优化多少 干货总结通过上面四个方面的回顾，我们对于Fragment对认识应该有了一个整体的概念。 不过，千说万说，不如自己动手去实践，最好的方式还是自己亲自将Fragment相关的一些实现用代码实现出来，遇到了坑，就会对某一个问题有了深刻理解。 虽然Google也推荐我们尽量使用少Activity + 多Fragment的方式进行项目开发，但是，Fragment依然有些坑，我们在用的时候还是需要注意的。 下面大概说几个我们在实际开发中使用Fragment的时候需要注意的地方： 1. 在同一个Activity中，只能存在一个id（Fragment的唯一标识）标识的Fragment实例。因为有可能在布局的时候会出现不允许创建的错 误。 2. FragmentManager的作用范围是整个Activity，因此某一个布局中的Fragment ID,不能重复进行替换。因为FragmentManager只认布局 中的ID，如果有多个实例都是用的这一个布局ID，也只会显示一个。 3. Fragment的可见性并没有像Activity那么方便操作，当A Fragment被B Fragment覆盖的时候，A此时是会回调Fragment的onStop()方 法，但当B Fragmeng从栈中回退后，A Fragment无法感知自己正处于栈顶，需要我们开发人员自行监听一些状态来判断A Fragment是否对于 用户可见 4. Fragment的事件传递也需要注意，处于顶部的Fragment需要注意判断是否该消费此点击事件，否则如果存在多个Fragment层叠现象，可能 下层的Fragment会消费此事件。 ... 所以，我们在实际开发当中，还是需要了解当前功能使用Fragment是否OK，如果有问题，是否有相应的解决方案。 好了，关于Fragment的一些知识点就先回顾到这里。 如果喜欢本篇文章的内容或者讲述形式，希望给一个喜欢和赞，如果有什么不对的地方，或者需要改进的地方，也希望能够留言说一下，谢谢了。]]></content>
      <categories>
        <category>Android基础知识回顾</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>activity</tag>
        <tag>生命周期</tag>
        <tag>fragment</tag>
        <tag>fragmeng通信</tag>
        <tag>FragmentManager</tag>
        <tag>FragmentTransaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础知识回顾之Activity]]></title>
    <url>%2Farchives%2F2017%2F08%2F20%2FAndroid%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E4%B9%8BActivity%2F</url>
    <content type="text"><![CDATA[开篇废话最近公司忙着搬迁，没有太多的精力去分享一些比较耗时间的知识，随之就跟着之前的计划，开始回顾一下Android相关的基础知识。 今天我们一起来回顾一下我们接触最多，相对来说最熟悉的组件，Activity。 其实，当我在想什么是Activity的时候，确实有那么一会儿懵逼的感觉，因为不知道该如何组织语言去表达。 在这里，我大概说一下我的理解，到时候与别人交谈的时候，可以用这个思路来表达： 在我们日常应用中，Android是与用户交互的接口，它提供了一个界面让用户进行点击、各种滑动操作，这就是Activity的意义 技术详情这次的内容比较简单，看起来会比较轻松，我主要分四个角度来进行讲述： 1. Activity的生命周期 2. Android系统中的任务栈 3. Activity的启动模式 4. scheme跳转协议 1. Activity的生命周期1.1 Activity的四种状态running:表明activity处于活动状态，用户点击屏幕，屏幕可以作出响应，它是一个处于activity栈顶的状态 paused:表明activity失去焦点的时候，也许是被一个非全屏的activity占据，或者被一个透明的activity放置在activity栈顶，这种情况下，就处于paused状态，用户操作对它不会有响应，但并不代表它被销毁了，这时候，他所有的状态信息和成员变量都还在，除非系统内存非常紧张的时候，就有可能被销毁掉。 stopped: 当activity被另一个Activity完全覆盖的时候，被覆盖的那个activity就会处于stopped状态，当内存不紧张的时候，状态信息和成员变量也是还在的。 killed: 表明activity已经被系统回收掉了，状态信息和成员变量都已经不存在了。 1.2 Activity的生命周期分析首先，我们都需要看懂下面这张图： 大概分析几个场景的调用流程： 1.Activity启动 --&gt; onCreate() --&gt; onStart() --&gt; onResume() 2.点击Home键回到系统主界面的时候 --&gt; onPause() --&gt; onStop() 3.当我们再次回到原来的那个Activity的时候 --&gt; onRestart() --&gt; onStart() --&gt; onResume() 4.退出当前的Activity的时候 --&gt; onPause() --&gt; onStop() --&gt; onDestory() 5.A Activity 调用弹出B Activity的时候(完全覆盖) --&gt; A onPause() --&gt; B onCreate() --&gt; B onStart() --&gt; B onResume --&gt; A onStop() 6.Activity异常退出的时候 --&gt; onPause() --&gt; onSaveInstanceState() --&gt; onStop() --&gt; onDestory(), 需要注意的是onSaveInstanceState() 方法与onPause并没有严格的先后关系，有可能在onPause之前，也有可能在其后面调用，但会在onStop()方法之前调用 7.异常退出后又重新启动该Activity --&gt; onCreate() --&gt; onStart() --&gt; onRestoreInstanceState() --&gt; onResume() 1.3 Android中的进程优先级Android系统中，主要有这样五个进程优先级（按优先级高到低排列）： 1. 前台进程：一般情况下处于与用户进行交互的Activity或者与前台Activity绑定的Service 2. 可见进程：如果一个Activity处于可见但是不是处于前台，就是用户不能点击的情况下就是可见进程 3. 服务进程：就是在后台开启了一个Service服务，这就是服务进程 4. 后台进程：假设我们当前的Activity是前台进程，然后我们按下Home键，前台进程就变成了后台进程 5. 空进程：五个进程里面，优先级是最低的，如果我们的进程不属于上面四个进程的进程，那就是空进程，空进程系统可以随时杀死 2. Android系统中的任务栈我们的Android系统为了记录用户开启了哪些Activity,记录这些Activity开启的先后顺序，所以引入了任务栈(Task Stack)的概念，可以增强用户的体验。 任务栈与下面讲的启动模式其实密切相关，关于任务栈相关的知识点如下： 1. 任务栈，Task Stack，别名Back Stack（后退栈），记录存放用户开启的Activity 2. 我们的App开启的时候，Android系统就给这个App分配了一个任务栈，当所有的Activity都退出的时候，任务栈就清空了 3. 我们的App的任务栈并不是唯一的，可能不止一个任务栈，一个Activity也可以独享一个任务栈 4. 清空了任务栈，我们的App的进程并不会销毁，还是会保留 5. 任务栈可以移动到后台，并且保留了每一个Activity的状态信息和成员变量 6. 只有在栈顶的Activity才能与用户进行交互 3. Activity的启动模式Android系统中Activity的启动模式主要有四种： 1. standard 2. singleTop 3. singleTask 4. singleInstance 3.1 standard这个模式，我们平时开发中使用得比较多，属于默认模式，可以指定，也可以不用配置。 在这个模式下，都会默认创建一个新的实例。也就意味着在一个任务栈中，可能存在多个相同的实例，也可以多个相同的Activity进行叠加 可以在清单文件里面进行指定该启动模式： 当前栈内顺序是A B C D，这个时候，在栈顶的D Activity启动A Activity,由于是A是Standard模式，那么就会在当前任务栈重新创建一个新的实例A，那么任务栈就变成了A B C D A。 3.2 singleTop我们一般都称此模式为栈顶复用，表明与Standard不同的是，并不是每次都无脑的进行重新创建一个实例，需要进行判断。当被启动的Activity已经处于栈顶，就不会进行创建新的实例，而是调用栈顶Activity的onNewIntent方法，当然，如果栈顶的Activity并不是被启动的但是同一个任务栈的，依然会重新创建一个实例 3.3 singleTask这个模式，我们中文称作栈内复用，与栈顶复用差不太多，只是，判断的是当前Activity处于的整个任务栈。如果在整个任务栈中，已经有当前Activity的实例，那就是调用该Activity的onNewIntent方法，而不会重新创建实例。 这个模式值得注意的是，当需要复用当前任务栈中的某一个Activity实例的时候，会直接把该实例上面的Activity进行出栈进行销毁，从而将该Activity实例放于栈顶。 3.3 singleInstance这个模式比较特殊，当使用该模式的时候，会创建一个新的任务栈，而且，这个任务栈有且仅有这一个Activity实例。 如果再一次调用这个Activity实例，就会发生发用，调用它的onNewIntent方法，反正不会再重新创建一个了。 值得注意的是，按返回退出的时候，是一个任务栈都出栈完了之后，再操作另一个任务栈。 4. scheme跳转协议Android中的scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转到我们App中的各个页面； 通过scheme协议，服务器也可以定制化告诉App跳转到那个页面，可以通过通知栏消息定制化跳转页面，也可以通过H5页面跳转到页面等。 下面简单讲一下scheme的使用。 第一步，将满足scheme协议的Activity在清单文件里面进行注册： &lt;activity android:name=&quot;.SecondActivity&quot; android:launchMode=&quot;singleTask&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;senduo&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 第二步，在需要调用的地方，定义URI格式（也就是我们自定义的协议），其中格式URI格式如下： [scheme:][//domain][path][?query][#fragment] 代码举例说明如下： tvDomain = (TextView) findViewById(R.id.tvDomain); tvDomainWithParams = (TextView) findViewById(R.id.tvDomainWithParams); tvDomain.setText(Html.fromHtml(&quot;&lt;a href=&apos;senduo://domain/path?params&apos;&gt;无参示例&lt;/a&gt;&quot;)); tvDomain.setMovementMethod(LinkMovementMethod.getInstance()); tvDomainWithParams.setText(Html.fromHtml(&quot;&lt;a href=&apos;senduo://second_activity?id=123456&amp;name=senduo&apos;&gt;有参示例&lt;/a&gt;&quot;)); tvDomainWithParams.setMovementMethod(LinkMovementMethod.getInstance()); 第三步，在onCreate方法或者onNewIntent方法中进行URI的解析，根据实际的业务逻辑进行处理 @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); Uri uri = intent.getData(); if (uri != null) { dispatchUri(uri); } else { Log.e(TAG, &quot;Uri is null&quot;); } } //URI的解析 private void dispatchUri(Uri uri) { try { final String domain = uri.getAuthority(); if (TextUtils.equals(SECOND_DOMAIN, domain)) { final int id = Integer.valueOf(uri.getQueryParameter(&quot;id&quot;)); final String name = uri.getQueryParameter(&quot;name&quot;); Toast.makeText(this, id + &quot; &quot; + name, Toast.LENGTH_SHORT).show(); } } catch (Exception e) { Log.e(TAG, &quot;Uri Parse Error&quot;); } } 关于scheme的调用，可以根据具体的实际业务场景进行自行设计，像通知栏的跳转，网页的跳转啥的，具体的内容可以查看相关博客进行更深一步的学习。 干货总结以上，是这一次关于Activity知识的一个整理，其实，Activity的知识点可以讲的很简单，也可以深入Framework层进行分析，那样理解起来会比较吃力，但收获也将不少。奈何最近各种需要干苦力，这些分析就留到Android源码分析的时候再深入了解吧。 我们作为一个Android开发人员来讲，Activity是四大组件中离我们最近，接触得最多的一个，需要对它的一些原理，机制有一定的了解，希望通过这一篇文章，能够提供一个清晰的思路来回顾Activity，能够回答以下问题： 1. 什么是Activity 2. activity有哪些状态 3. 手绘Activity的生命周期图 4. Android系统中的进程优先级 5. Activity的四种启动模式简述 6. scheme跳转协议是什么]]></content>
      <categories>
        <category>Android基础知识回顾</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>activity</tag>
        <tag>任务栈</tag>
        <tag>生命周期</tag>
        <tag>启动模式</tag>
        <tag>scheme</tag>
        <tag>standard</tag>
        <tag>singleTop</tag>
        <tag>singleTask</tag>
        <tag>singleInstance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能调优篇之内存溢出]]></title>
    <url>%2Farchives%2F2017%2F08%2F16%2FAndroid%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87%E4%B9%8B%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[开篇废话上一篇我们了解了Android里面相关的内存泄露以及相应的处理方案，这一篇，接着上一篇的内存泄露的内容，讲一下Android当中的内存溢出。 内存溢出与内存泄露，很多开发人员都容易产生混淆，有可能是因为这两个概念有点关系，又因为名称上也不太好区分吧。不过，我们依然要清楚，内存溢出（Out Of Memory Error） 与 内存泄露 （Memory Leak）还是有质的区别的。都我们的App多次出现内存泄露，可能就会导致内存溢出。 但是，我们的App出现内存溢出，不一定就是因为内存泄露，因为本身Android系统分配给每一个的App的空间就是那么一点。 另外，内存泄露也不一定就会出现内存溢出，因为还是泄露的速度比较慢，系统将进程杀死了，也就不会内存溢出咯，不过，发现内存泄露，我们还是要第一时间解决掉这个bug。 技术详情讲述逻辑如下： 1.什么是内存溢出 2.有些内存里面容易混淆的概念 3.如何解决内存溢出 1.什么是内存溢出内存溢出，OOM(Out Of Memory),表示当前占用的内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存限制就会抛出的Out Of Memory异常。大部分的OOM的问题，都会与Bitmap的加载有关系 2.内存里面容易混淆的一些概念主要有三个概念： 1.内存溢出 2.内存抖动 3.内存泄露 其中第一个内存溢出，就是刚刚讲的OOM,第三个内存泄露，可以查看我的上一篇文章。 关于第二个内存抖动，出现的情况是，短时间内，大量的对象被创建，然后又马上被释放，瞬间产生的对象会严重占用内存区域，这个区域就是我们之前接触的那个年轻代区域，到达这个区域的阈值时就会触发minor gc,当出现频繁的minor gc的时候，就会出现内存抖动，我们能够通过我们的Android Studio的Memory Monitor能够非常直观的看到内存抖动 出现内存抖动的现象，可根据当前app处理的实际业务结合Memory Monitor中的现象来进行判断，然后有针对性的进行优化。 它们三者的重要等级分别：内存溢出 &gt; 内存泄露 &gt; 内存抖动 内存溢出对我们的App来说，影响是非常大的，整得不好，就有可能导致程序闪退，无响应等现象，因此，我们一定要优先解决OOM的问题。 3.如何解决内存溢出如何解决OOM，这个问题范围比较大，我这边大概从两个方面去讲述： 1.关于Bitmap的OOM 2.除了Bitmap之外的OOM 3.1 关于Bitmap的OOM关于Bitmap的OOM我们有几点需要注意的。 3.1.1 ImageView等控件图片的显示意思就是加载合适属性的图片，当我们有些场景是可以显示缩略图的时候，就不要调用网络请求加载大图，例如在ListView中，我们在上下滑动的时候，就不要去调用网络请求，当监听到滑动结束的时候，才去加载大图，以免上下滑动的时候产生卡顿现象。 3.1.2 及时释放内存我们知道，在Android系统中，本身就有自己的垃圾回收机制，系统会不定期进行垃圾回收的。但是，这个只是针对Java那一块的内存,但是我们需要知道Bitmap实例化的时候，是通过JNI的方式，所以还有一部分的内存是C那一块的，我们的GC没有办法回收，所以，我们在不用的时候，还是需要调用recycle()方法，源码里面，recycle()方法其实就是调用的JNI的函数，然后释放C那一块的内存。 3.1.3 把图片进行压缩我们在实际开发过程当中，可能因为业务需要，需要加载一张很大的图片，大到直接可以超过系统分配给我们App的内存大小，这样，就会直接导致内存溢出，那么，这个时候，我们就应当控制图片的大小，那么就应该将bitmap进行压缩了。 下面大概讲一下对一张图片进行压缩的一个过程。 第一步：计算实际采样率 /** * 计算压缩比例值 * @param options 解析图片的配置信息 * @param reqWidth 所需图片压缩尺寸最小宽度 * @param reqHeight 所需图片压缩尺寸最小高度 * @return */ public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { //保存图片原宽高值 final int height = options. outHeight; final int width = options. outWidth; //初始化压缩比例为1 int inSampleSize = 1; //当图片宽高值任何一个大于所需压缩图片宽高值时,进入循环计算系统 if (height &gt; reqHeight || width &gt; reqWidth) { final int halfHeight = height / 2; final int halfWidth = width / 2; //压缩比例值每次循环两倍增加, //直到原图宽高值的一半除以压缩值后都~大于所需宽高值为止 while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) { inSampleSize *= 2; } } return inSampleSize; } 第二步：根据得到的采样率对图片进行解析 /** * 获取压缩后的图片 * @param res * @param resId * @param reqWidth 所需图片压缩尺寸最小宽度 * @param reqHeight 所需图片压缩尺寸最小高度 * @return */ public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) { //首先不加载图片,仅获取图片尺寸 final BitmapFactory.Options options = new BitmapFactory.Options(); //当inJustDecodeBounds设为true时,不会加载图片仅获取图片尺寸信息 options.inJustDecodeBounds = true; //此时仅会将图片信息会保存至options对象内,decode方法不会返回bitmap对象 BitmapFactory.decodeResource(res, resId, options); //计算压缩比例,如inSampleSize=4时,图片会压缩成原图的1/4 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); //当inJustDecodeBounds设为false时,BitmapFactory.decode...就会返回图片对象了 options. inJustDecodeBounds = false; //利用计算的比例值获取压缩后的图片对象 return BitmapFactory.decodeResource(res, resId, options); } 3.1.4 使用Bitmap的高级属性inBitmapBitmap的inBitmap高级属性主要是值复用内存块，不需要在重新给新的bitmap对象申请一块新的内存，避免了一次内存的分配和回收，从而提供了我们程序运行的效率。 不过这个属性还是有一些坑的，对于适配Android3.0以上 。而且，这个功能，google一直在优化当中，在Android4.4以前，只能复用相同大小的bitmap内存，而4.4之后，则只要比之前的内存小，就可以了。以下贴出inBitmap的简单使用方法： 第一步：首先判断当前图片是否能够使用inBitmap /** * 判断是否能够使用inBigmap * @param candidate 比较标准 * @param targetOptions 判断目标对象属性 * @return */ public static boolean canUseForInBitmap( Bitmap candidate, BitmapFactory.Options targetOptions) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { // From Android 4.4 (KitKat) onward we can re-use // if the byte size of the new bitmap is smaller than // the reusable bitmap candidate // allocation byte count. int width = targetOptions.outWidth / targetOptions.inSampleSize; int height = targetOptions.outHeight / targetOptions.inSampleSize; int byteCount = width * height * getBytesPerPixel(candidate.getConfig()); return byteCount &lt;= candidate.getAllocationByteCount(); } // On earlier versions, // the dimensions must match exactly and the inSampleSize must be 1 return candidate.getWidth() == targetOptions.outWidth &amp;&amp; candidate.getHeight() == targetOptions.outHeight &amp;&amp; targetOptions.inSampleSize == 1; } 第二步：从缓存里面拿出bitmap,将此Bitmap赋值给inBitmap。 /** * 将Bitmap赋值给inBitmap * @param options 图片的配置信息 * @param cache 图片缓存 */ private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) { //inBitmap only works with mutable bitmaps, so force the decoder to //return mutable bitmaps. options.inMutable = true; if (cache != null) { // Try to find a bitmap to use for inBitmap. Bitmap inBitmap = cache.getBitmapFromReusableSet(options); if (inBitmap != null) { // If a suitable bitmap has been found, // set it as the value of inBitmap. options.inBitmap = inBitmap; } } } 第三步：调用刚刚图片压缩时候的decode方法，把options参数传入 3.1.5 捕获异常很多时候，当内存确实很吃紧的时候，难免还是会出现OOM，所以，根据经验之谈，我们在开发过程中，实例化Bitmap的时候，最好还是添加try catch，进行异常捕获。 需要注意，平常的Exception异常是捕获不到OOM Erro的，因为OOM是一个错误，我们编码的时候需要捕获错误，具体给出以下示例代码： public static Bitmap createBitmap(int width, int height, Bitmap.Config config) { Bitmap bitmap = null; try { bitmap = Bitmap.createBitmap(width, height, config); } catch (OutOfMemoryError e) { while(bitmap == null) { System.gc(); System.runFinalization(); bitmap = createBitmap(width, height, config); } } } 3.2 除了Bitmap之外的OOM3.2.1 listview这个listview确实提到了好多次，毕竟我们实际开发当中，用它来呈现一些数据确实的频率也蛮高，还是需要讲述一下。 使用listview的时候，一定要记得复用convertView 同时，在listview当中，如果需要显示大图的控件，记得使用LRU（最近最少使用，三级缓存）机制进行缓存图片 3.2.2 onDraw方法当中，尽量避免对象的创建如果在onDraw方法中创建对象，会触发频繁的GC,也就是之前提到的内存抖动，当内存抖动积累到一定的程度，也会出现内存溢出。 3.2.3 使用多进程，一定要小心小心再小心我们有的时候需要将一些服务，或者主件放到另外一个进程去运行，例如一些定位，推送等，这样确实可以分担主进程的内存压力。 但是，多进程中的一些通信真心没有那么简单。很多机制可能失效，从而影响业务的基本功能。可能会出现一些莫名其妙的crash. 所以，如果我们的App实际业务没有达到一定程度，真心不要使用多进程。 干货总结此篇文章根据OOM是什么，了解一些容易混淆的概念，然后熟悉一些OOM的解决方案这个逻辑，再结合实际开发可能遇到的问题，讲述了内存溢出的相关知识。其实，大篇幅都是在讲述Bitmap的处理方案，因为，我们这个Bitmap确实在实际开发当中引发OOM的概率还是相当大的。 希望通过以上的讲述，我们能够对于OOM有一个清晰的了解，从而根据我们实际开发当中自己的业务，进行OOM的优化。 其实有的时候，我们在解决OOM的时候需要有一个权衡，因为如果考虑到了OOM的情况而频繁触发GC,可能会导致UI卡顿的现象，跟严重的可能出现ANR的问题，需要我们在实际开发过程中具体场景具体分析。 好了，内存的泄露的知识就先更新到这了，如果觉得本篇文章对大家有益，请给予一个赞和喜欢，这样我才更有动力一直更新下去，如果和一起探讨的，可以关注一波。]]></content>
      <categories>
        <category>Android性能调优</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>JVM</tag>
        <tag>内存泄露</tag>
        <tag>内存分配</tag>
        <tag>JVM内存模型</tag>
        <tag>java内存分配</tag>
        <tag>内存溢出</tag>
        <tag>内存抖动</tag>
        <tag>图片压缩</tag>
        <tag>inBitmap</tag>
        <tag>inSampleSize</tag>
        <tag>多进程</tag>
        <tag>listview</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能调优篇之内存泄露]]></title>
    <url>%2Farchives%2F2017%2F08%2F15%2FAndroid%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[开篇废话通过我之前的两篇文章 Android性能调优篇之探索JVM内存分配 Android性能调优篇之探索垃圾回收机制 我们大概了解了Java内存的一些基本知识，这个对于本篇文章的要讲的内存泄露，还是挺有帮助的。 本来最开始就想写关于内存泄露的文章的，由于它涉及了一些Java内存的基本知识，所以为了铺垫，写下了内存分配机制以及垃圾回收的两篇文章。 关于内存泄露，Memory Leak,我想基本上所有开发人员都多多少少接触过这个概念，因为它确实与我们的实际开发脱不了干系。这次我讲述内存泄露的角度主要是从Android实际开发的角度。 技术详情1.什么是内存泄露所谓内存泄露，就是指我们不再使用的对象持续占有内存，或者这些不再使用的对象没有办法得到及时释放（GC Roots依然可达），而导致内存空间的浪费。值得注意的是，我们App的内存泄露的不断积累，最终会导致OOM（Out Of Memory），更严重的导致程序崩溃，所以我们平时一定要处理内存泄露。 2.Android中的内存泄露2.1 单例我们通过代码，来看一下单例模式产生的内存泄露。 首先是单例类OyTestManager.java(这里就不写关于实际业务的代码了)： 123456789101112131415161718192021222324252627282930import android.content.Context;/** * ***************************************************************** * * 文件作者：ouyangshengduo * * 创建时间：2017/8/14 * * 文件描述：单例模式演示内存泄露 * * 修改历史：2017/8/14 21:41************************************* **/public class OyTestManager &#123; private static OyTestManager mInstance; private Context mContext; private OyTestManager(Context mContext)&#123; this.mContext = mContext; &#125; public static OyTestManager getmInstance(Context mContext)&#123; if(null == mInstance)&#123; synchronized (OyTestManager.class)&#123; if(null == mInstance)&#123; mInstance = new OyTestManager(mContext); &#125; &#125; &#125; return mInstance; &#125;&#125; 然后再MainActivity.java里面使用这个单例： 1234567891011121314151617181920212223242526import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; private OyTestManager oyTestManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); &#125; /** * 数据初始化 */ private void initData()&#123; oyTestManager = OyTestManager.getmInstance(this); &#125;&#125; 代码非常简单，这里只是为了讲解我们实际开发中使用单例造成的内存泄露，通过上面的代码，我们使用Android Studio里面的Android Monitor进行内存泄露的分析（也可以使用其他的工具，如MAT），分析步骤为： 1 将以上代码在Android设备上跑起来，然后点击返回退出软件 2.点击Android Studio的Android Monitor中的Initiate GC,触发系统的一次GC，具体操作截图如下： 3.然后点击Initiate GC旁边的Dump Java Heap,将此时的系统的Java堆的情况导出来，稍等一会，会生成一个.hprof的文件具体操作截图如下： 4.点击任务分析按钮，开始分析，分析结束会有一个分析结果，具体查看分析结果中的内容，看我们的软件退出之后，是否还有资源没有得到释放 从以上操作中，我们能够看出，我们的MainActivity已经退出了，但系统并没有回收掉这个MainActivity,因为在MainActivity中使用了单例模式，mInstance这个静态对象与MainAcitivty依然存在引用关系，从之前的内存相关的知识可以知道，mInstance在这里就可以作为一个GC Root，因为从GC Root开始进行搜索，对于MainActivity这个对象是可达的，所以，系统没有回收掉这个对象。 知道了原因，我们就可以对其进行优化了。 我们知道单例的静态特性与我们的App的生命周期是一样长的，所以，我们只需要把MainActivity的引用替换成我们的ApplictionContext,这样，系统就能回收掉MainActivity对象了，以下是单例模式进行优化后的写法： 1234567891011121314151617181920212223242526272829303132import android.content.Context;/** * ***************************************************************** * * 文件作者：ouyangshengduo * * 创建时间：2017/8/14 * * 文件描述：单例模式演示内存泄露 * * 修改历史：2017/8/14 21:41************************************* **/public class OyTestManager &#123; private static OyTestManager mInstance; private Context mContext; private OyTestManager(Context mContext)&#123; this.mContext = mContext.getApplicationContext(); &#125; public static OyTestManager getmInstance(Context mContext)&#123; if(null == mInstance)&#123; synchronized (OyTestManager.class)&#123; if(null == mInstance)&#123; mInstance = new OyTestManager(mContext); &#125; &#125; &#125; return mInstance; &#125;&#125; 在构造方法中this.mContext = mContext 改成了：this.mContext = mContext.getApplicationContext(); 通过以上的写法，我们再进行上面那种分析方法，就不会出现Leaked Activity这一项了，也就意味着，我们已经对这个单例优化成功了。 2.2 匿名内被类匿名内部类，在Java当中，非静态内部类默认将会有持有外部类的引用，当在内部类实例化一个静态的对象，那么，这个对象将会与App的生命周期一样长，又因为非静态内部类一直持有外部的MainActivity的引用，导致MainActivity无法被回收，内存泄露的代码如下： 12345678910111213141516171819202122232425262728293031import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; private OyTestManager oyTestManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); &#125; /** * 数据初始化 */ private void initData()&#123; oyTestManager = OyTestManager.getmInstance(this); &#125; //定义一个内部类 class LeakTest&#123; private static final String TAG = &quot;Just a test&quot;; &#125;&#125; 用上面的分析方法区分析，同样会出现Leaked Activities,也就是存在内存泄露 这种情况，我们需要把匿名内部类修改为静态内部类，静态内部类，这样静态内部类就不会持有外部MainActivity的引用，从而不会有内存泄露的问题，优化后的代码如下： 123456789101112131415161718192021222324252627282930import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; private OyTestManager oyTestManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); &#125; /** * 数据初始化 */ private void initData()&#123; oyTestManager = OyTestManager.getmInstance(this); &#125; //定义一个内部类 static class LeakTest&#123; private static final String TAG = &quot;Just a test&quot;; &#125;&#125; 2.3 HandlerHandler 我们应该比较熟悉，我们通常使用它来进行子线程到主线程的UI更新。不过，我们实际开发中，因为Handler而造成的内存泄漏是最常见的，比如说，我们平时处理一些网络数据获取的时候，会请求一个回调，然后我们会使用Handler进行处理。这个时候，如果我们没有考虑到内存泄露，就会造成比较严重的问题。 首先，我们平时使用Handler 都是这样的： 123456private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; //业务逻辑代码 &#125; &#125;; 我们来分析一下这种写法： 1234561.mHandler在这里是Handler的非静态内部类的一个实例，会持有外部类MainActiivty的引用2.Handler的消息队列是在Looper线程中不断轮询处理消息，当我们的MainActivity退出的时候，消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message又持有mHandler的实例引用，而且，mHandler也持有外部类MainActivity的引用，导致系统无法对MainActivity进行回收，而造成内存泄露 所以，这种写法无法保证mHandler的生命周期与MainActivity一样，很经常造成内存泄露。 而正确的写法是把Handler改成MainActivity的一个静态内部类，同时在其内部持有外部类的弱引用，这样就能解决好这个内存泄露问题： 12345678910111213141516private MyHandler mHandler = new MyHandler(this);private static class MyHandler extends Handler&#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context)&#123; reference = new WeakReference&lt;Context&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity mainActivity = (MainActivity) reference.get(); if(mainActivity != null)&#123; //业务处理逻辑 &#125; &#125;&#125; 2.4 尽量避免使用static变量我们平时实际开发中，经常会使用static的变量，能够在不同的类和包中使用，但我们需要知道，static变量的还是有一些坑的： 12345671.占用内存，系统一般不会进行释放2.当系统内存不够用的时候，会自动回收静态内存，这样就有可能导致我们的程序访问某一个静态对象的时候发生不可预测的错误。3.当Android App退出的时候，进程并没有马上退出，app的一些静态变量还存在内存中，这是不安全的。 因此，我们使用static变量的时候的，必须考虑好真的有没有必要使用static模型，一旦static使用的不合理，会造成大量的内存浪费。很多时候，我们可以在Application里声明定义全局变量，或者使用持久化数据存储来保存全局变量。 2.5 资源未关闭造成的内存泄漏资源未关闭的情况，这个我们平时开发中，应该会比较重视，因为特别容易出现内存泄露，最终导致程序内存溢出而崩溃，因为容易呈现，所以我们知道其必要性。 当我们使用了BroadcastReceiver,ContentObserverr,File,Cursor,Stream,Bitmap等资源的时候，使用完一定要记得及时关闭或者销毁。 例如，我们一般在某个Activity中register了某一个广播BroadcastReceiver,在Activity结束的时候没有调用unregister,这明显就会造成内存泄露。 还有的时候使用查询数据库，读取文件等一些资源型对象的时候，一定要记得调用关闭的方法。 还就是Bitmap的调用了，这个东西特别占用内存，使用完可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存。 2.6 AsnycTask造成的内存泄露其实AsnycTask造成的内存泄露的原理与Handler是一样的，主要还是因为非匿名内部类持有外部类的引用，在AsnycTask的doInBackground的方法中，可能还有任务正在处理，从而导致Activity不能被释放。 解决方案也可以使用静态内部类，也可以在Activity的onDestory方法中调用cancle方法，我这里就不贴代码了。 干货总结以上介绍了我们Android开发中，经常遇到的六种内存泄露的情况，实际上内存泄露远不及这六种，牵扯到方方面面，很多时候，有些内存泄露并不能百分百的去解决，需考虑一些系统的权衡来制定方案。关于内存泄露，有些点在我们编码过程中还是需要再次重申一下： 1234567891011121314151.恰当使用单例模式，Handler机制2.资源对象使用完了，一定要记得关闭或者释放掉3.老生常谈的ListView,一定要记得使用缓存convertView4.Bitmap对象使用完了要记得调用recycle()方法来释放底层C那一块的内存5.可能的话，将Activity的相关的context,用Application的context来替代6.集合当中存放的对象引用，某个对象使用完了，记得从这个集合当中清理掉该引用7.匿名内部类也要慎用，可能的话，用静态内部类替代，避免持有外部类引用而导致外部类无法被回收8.熟悉内存泄露检查和分析的工具，如MAT,LeakCanary,Android Monitor等工具]]></content>
      <categories>
        <category>Android性能调优</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>JVM</tag>
        <tag>内存泄露</tag>
        <tag>memory leak</tag>
        <tag>handler</tag>
        <tag>static</tag>
        <tag>asyncTask</tag>
        <tag>单例模式</tag>
        <tag>引用</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能调优篇之探索垃圾回收机制]]></title>
    <url>%2Farchives%2F2017%2F08%2F13%2FAndroid%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87%E4%B9%8B%E6%8E%A2%E7%B4%A2%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[开篇废话如果我们想要进行内存优化的工作，还是需要了解一下，但这一块的知识属于纯理论的，有可能看起来会有点枯燥，我尽量把这一篇的内容按照一定的逻辑来走一遍。首先，我们为什么要学习垃圾回收的机制，我大概归纳了一下几点： 12345671.方便我们理解什么样的对象，什么时候，会被系统回收掉2.有助于我们后面的内存优化3.了解这一块的知识也能提升自己的知识广度，和同事一起装逼的时候有话题4.如果有面试的需求的话，了解这一块，也能从容面对考官，对于内存回收能够说出个一二 好了，废话不多说了，我大概按以下这个逻辑来一个一个讲述： 123451.什么是垃圾回收（GC）2.垃圾回收机制对于我们来说有什么好处？又有什么缺点？3.垃圾回收它是如何工作的？ 技术详情1.什么是垃圾回收（GC）垃圾回收或GC（Garbage Collection）,是一种自动的存储管理机制，它是Java语言的一大特性，方便了我们这些程序员编码，把内存释放工作的压力都转让到了系统，故而是以消耗系统性能为代价的。C++编码的时候，我们 需要自己实现析构函数来进行内存释放，很麻烦，而且非常容易遗漏而最终导致程序崩掉。所以Java语言就引入了自动内存管理的机制，也就是垃圾回收机制，针对的主要的内存的堆区域，关于内存的分配机制，请查看我的上一篇Android性能调优篇之探索JVM内存分配 2.垃圾回收机制对于我们来说有什么好处？又会带来哪些坑？以下我列举一下系统自动垃圾回收给我们带来的一些好处： 1231.让作为程序员的我们专注于逻辑实现，提高了我们的编码效率2.能够保护程序的完整性，垃圾回收是Java语言的安全策略的一个重要部分 但是随之的，也会到来一些缺点： 1231.系统层面负责垃圾回收，明显会加大系统资源的开销，从而影响程序的性能2.垃圾回收机制也存在不完备性，并不能百分百保证回收所有的垃圾内存 3.垃圾回收它是如何工作的？其实，GC是主要的一个流程是：先根据一定的算法判定某个对象是否存活，然后把判定是垃圾的对象进行回收。详细点说的话，GC的工作流程分以下几个步骤： 1231.可回收对象的判定2.通过某些算法回收垃圾内存 下面一个一个进行讲述 1.可回收对象的判定我们的GC需要把某个对象回收掉，肯定是需要判断它到底是不是垃圾，是不是需要被回收，因此，就需要对每一个对象进行可回收判定。 目前，市面上存在有两种算法来判定一个对象是否是垃圾 1.引用计数算法这种算法的工作原理是: 12345671.首先给每一个对象都添加一个引用计数器2.当程序的某一个地方引用了此对象，这个计数器的值就加13.当引用失效的时候（例如超过了作用域），这个计数器就减14.当某一个对象的计数器的值是0的时候，则判定这个对象不可能被使用 这种算法对于系统来说比较简单，高效，垃圾回收器运行较快，不需要长时间中断我们的程序的执行，但是缺点是很难处理循环引用，这就导致相互引用的对象都无法被回收： 我记得OC（Objective-C）中的垃圾判定就是用的引用计数方法，引用了一个第三方变量来打破这个平衡，但OC也没有很好的解决这个问题，而是更多的依靠我们这些开发者来处理。 2.GC Root可达性分析算法这个算法的工作原理是： 123451.以称作“GC Root”的对象作为起点向下搜索2.每走过一个对象，就生成一条引用链3.从根开始到搜索完，生成了一棵引用树，那些到GC Root不可达的对象就是可以回收的 这个方法明显就解决了循环引用的问题，不过这个算法还是稍微有点复杂的,以下是GC Root可达性算法的一个图解： 我们程序中能够被用来当做GC Root对象的有： 12345671.虚拟机栈（栈帧中的本地变量表）中引用的对象2.方法区中静态属性引用的对象3.方法区中常量引用的对象4.本地方法栈中JNI引用的对象 以下拿一个图来进行引用计数算法与可达性分析算法的比较： 文字说明：1231.若使用引用计数算法判定，但图中的C和D对象存在相互引用，导致计数器不为0，无法回收掉2.若使用可达性分析算法，C和D对象到GC Roots 不可达，则能够回收 关于对象可回收的判定，我们还需要注意的是，当系统开始启动GC的时候，为了保证引用链的状态不变，就需要停止该进程中所有的程序（Stop The World），我们Android中的现象就是UI卡顿了，但一般这样的卡顿时间是非常短的，当然，要是频繁的产生GC，那就另当别论了。 还有值得注意的是，不可达对象也并非立即就被回收了，还需要经过两次的标记过程后才被会被真正回收： 12345671.如果对象与GC Root没有连接的引用链，就会被第一次标记，随后判定该对象是否有必要执行finalize()方法2.如果有必要执行finalize()方法，则这个对象就会被放到F-Queue的队列中，稍后由虚拟机建立低优先级的Finalizer线程去执行，但并不承诺等待它运行结束（对象类中能够重写finalize()方法进行自救，但系统最多只能执行一次）3.如果没必要执行finalize()方法，则第二次标记 2.通过某些算法回收垃圾内存以上内容讲述了系统如何去判定某一个对象是否是垃圾，是否应该被回收。接着，当判定了某一个对象为垃圾对象后，系统就要开始进行回收了，那么系统的垃圾回收算法以下几种： 12345671.标记清除算法(Mark-Sweep)2.复制算法(Copying)3.标记整理算法(Mark-Compact)4.分代回收算法 以下进行一一讲述 1.标记清除算法(Mark-Sweep)顾名思义，这个算法是先进行标记，然后进行清除，也正是这个算法的两个阶段：标记阶段和清除阶段，以下图解： 从图中可以看出： 123这个算法的优点是易于理解，容易实现，只需要将特定地址的空间进行处理。但缺点也比较明显，把整个内存区域弄得非常不完整，形成了很多碎片化的内存，对于分配大内存的对象时，无法申请足够的空间，从而更多次的触发GC 2.复制算法(Copying)复制算法，是对标记清除算法而导致内存碎片化的一个解决方案，算法原理如下： 1234561.如图所示,复制算法将内存平均分成两个区域A （上）和 B（下）2.将A中的存活的那些对象复制到B区域中3.然后将A区域的所有对象都清除，这样A区域就是一个完整的内存块了，也就避免了内存碎片化了 但是这个算法也有明显的缺点，那就是不管A区域或B区域有多少个存活对象，都需要将整块内存分成两个区域，意味着能够真正使用的内存变成了一半。 3.标记整理算法(Mark-Compact)标记整理算法是对于标记清楚的一个优化，工作原理是： 123451.如图所示，第一步也需要进行存活对象的一个标记，这一步与标记清除算法一模一样2.将存活的对象向一端移动，例如图中是往左上角那一端进行移动3.然后把另一端的内存进行清理 从图中也可以看出，这个算法也能避免内存碎片化的问题，但是效率确实不怎么样，毕竟相较于复制算法， 多了一步效率同样比较低的标记过程，而与标记清除算法相比，多了一步内存整理（往一端移动）的过程，效率上明显就更低了。 毕竟世界是公平的，任何算法都有两面性，我们开发者只能具体情况具体分析，使用最适合的算法。因此标记整理算法从图中可以看出，这个算法适合存活对象多的，回收对象少的情况。 4.分代回收算法鉴于以上三种算法都存在自己的缺陷，然后大神们就提出了根据不同对象的不同特性，使用不同的算法进行处理，所以严格来讲并不是一个新的算法，而是属于一种算法整合方案，我们知道： 1231.复制算法适用于存活对象少，回收对象多的情况2.标记整理算法适用于存活对象多，回收对象少的情况 这两种算法刚好互补，因此只要将这两个算法作用于不同特性的对象，就完美了。。 那么我们就应该知道，哪个区域的对象是什么样的特性，根据我的上一篇的内存分配模型，堆内存中的新生代有很多的垃圾需要回收，老年代有很少的垃圾需要回收，那么刚好能够根据这个特点使用不同的算法进行回收，具体使用的方式为： 1231.对于新生代区域采用复制算法，因为新生代中每次垃圾回收都要回收大部分对象，那么也就意味着复制次数比较少，因此采用复制算法更高效2.而老年代区域的特点是每次回收都只能回收很少的对象，一般使用的是标记整理或者标记清除算法 通过以上的方式，使得GC的整个过程达到了最高效的状态。 这里需要注意的是分代回收算法的中的复制算法的使用。 之前说的复制算法是将内存均分为二，但是在分代回收中，并不是这样，而是根据Eden:Survivor A:Survivor B= 8:1:1,具体的过程是(简化版)： 12345678910111213141.新创建一个对象，默认是分在Eden区域，当Eden区域内存不够的时候，会触发一次Minor GC(新生代回收)，这次回收将存活的对象放到Survivor A区域，然后新的对象继续放在Eden区域2.再创建一个新的对象，要是Eden区域又不够了，再次触发Minor GC，这个时候会把Eden区域的存活对象以及Survivor A区域的存活的对象移动到Survivor B区域，然后清空Eden区域以及Survivor A区域3.如果继续有新的对象创建，不断触发Minor GC，有些对象就会不断在Survivor A区域以及Survivor B区域来回移动，但移动次数超过15次后，这些对象就会被移动到老年代区域4.如果新的对象在Minor GC后还是放不下，就直接放到老年代5.如果Survivor区域放不下该对象，这直接放到老年代6.如果老年代也满了，就会触发一次Full GC(major gc) 干货总结通过以上的讲述，我们了解了什么是GC，它的优缺点，它是如何工作的，整过过程下来，脑子里也算有了一个GC的概率模型在了。 本文参考了以下博客： 理解Android Java垃圾回收机制 JAVA垃圾回收机制 掌握好GC策略和原理，对于我们编码来说能够避免一些不必要的内存泄露，我们使用Java语言进行开发，不要一味的去追求各种牛逼的框架或者酷炫的业务实现，有的时候，还是需要我们沉下心来，好好了解一下底层系统的一些机制，个人觉得还是很有必要的。]]></content>
      <categories>
        <category>Android性能调优</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>JVM</tag>
        <tag>内存分配</tag>
        <tag>JVM内存模型</tag>
        <tag>java内存分配</tag>
        <tag>内存</tag>
        <tag>java</tag>
        <tag>内存回收</tag>
        <tag>GC</tag>
        <tag>回收算法</tag>
        <tag>引用基数</tag>
        <tag>可达性分析</tag>
        <tag>标记</tag>
        <tag>整理</tag>
        <tag>复制</tag>
        <tag>分代回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能调优篇之探索JVM内存分配]]></title>
    <url>%2Farchives%2F2017%2F08%2F11%2FAndroid%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87%E4%B9%8B%E6%8E%A2%E7%B4%A2JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[开篇废话今天我们一起来学习JVM的内存分配，主要目的是为我们Android内存优化打下基础。 一直在想以什么样的方式来呈现这个知识点才能让我们易于理解，最终决定使用方法为：图解+源代码分析。 希望能在我们平时开发写代码的时候，能够知道当前写的这段代码，内存方面是如何分配的。我们深知，一个Java程序员在很多时候根本不用操心内存的释放，而是依靠JVM去管理，以前写C++代码的时候，却要时刻记着new的空间要及时释放掉，不然程序很容易出现内存溢出的情况。因为，Java在这方面确实方便了许多，让我们有更多精力去考虑业务方面的实现。但是，这并不意味着我们就能肆无忌惮的使用内存，因为： 1231.JVM并不会及时的去清理内存2.我们无法通过代码去控制JVM去清理内存 这就要求我们平时在开发过程中，要了解JVM的垃圾回收机制，合理安排内存。 那么怎么样才能合理安排内存呢？那么就需要我们了解JVM的内存分配机制，而后才能真正控制好，让程序运行在我们鼓掌之中。 技术详情1.JVM内存模型平时我们对于Java内存都有一个比较粗略的概念，就是分堆和栈，但实际上还是复杂得多，以下给出完整内存模型： 相对应区域的内容为： 1.1程序计数器PC这一个区域我概括了以下几个要点： 12345671.这一区域不会出现OOM（Out Of Memory）错误的情况2.属于线程私有，因为每一个线程都有自己的一个程序计数器，来表示当前线程执行的字节码行号3.标识Java方法的字节码地址，而不是Native方法4.处于CPU上，我们无法直接操作这块区域 1.2虚拟机栈这个区域也是我们平时口中说的堆栈的栈，关于这个块区域有如下要点： 12345678910111.属于线程私有，与线程的生命周期相同2.每一个java方法被执行的时候，这个区域会生成一个栈帧4.栈帧中存放的局部变量有8种基本数据类型，以及引用类型（对象的内存地址）5.java方法的运行过程就是栈帧在虚拟机栈中入栈和出栈的过程6.当线程请求的栈的深度超出了虚拟机栈允许的深度时，会抛出StackOverFlow的错误7.当Java虚拟机动态扩展到无法申请足够内存时会抛出OutOfMemory的错误 1.3本地方法栈这个区域，属于线程私有，顾名思义，区别于虚拟机栈，这里是用来处理Native方法（Java本地方法）的，而虚拟机栈是处理Java方法的。对于Native方法，Object中就有不少的Native的方法，hashCode,wait等，这些方法的执行很多时候都是借助于操作系统。 这一区域也有可能抛出StackOverFlowError 和 OutOfMemoryError 1.4 Java堆我们平时说得最多，关注得最多的一个区域，就是他了。我们后期进行的性能优化主要针对这部分内存，GC的主战场，这个地方存放的几乎所有的对象实例和数组数据。这里我大概进行了如下概括： 12345671.Java堆属于线程共享区域，所有的线程共享这一块内存区域2.从内存回收角度，Java堆可被分为新生代和老年代，这样分能够更快的回收内存3.从内存分配角度，Java堆可划分出线程私有的分配缓存区（Thread Local Allocation Buffer,TLAB）,这样能够更快的分配内存4.当Java虚拟机动态扩展到无法申请足够内存时会抛出OutOfMemory的错误 1.5 方法区方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。GC在该区域出现的比较少。概括如下： 123456789101.方法区属于线程共享区域2.习惯性加他永久代3.垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载4.常量池用于存放编译期生成的各种字节码和符号引用，常量池具有一定的动态性， 里面可以存放编译期生成的常量5.运行期间的常量也可以添加进入常量池中，比如string的intern()方法。 1.6 运行时常量池运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。单独拿出来说明一下，是因为我们平时使用String比价多，涉及到这一块的知识，但这一块区域不会抛出OutOfMemoryError 2.JVM内存源码示例说明首先写了一个main方法，来做演示，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package senduo.com.memory.allocate;/** * ***************************************************************** * * 文件作者：ouyangshengduo * * 创建时间：2017/8/11 * * 文件描述：内存分配调用过程演示代码 * * 修改历史：2017/8/11 9:39************************************* **/public class MemoryAllocateDemo &#123; public static void main(String[] args)&#123; //JVM自动寻找main方法 /** * 执行第一句代码，创建一个Test实例test，在栈中分配一块内存，存放一个指向堆区实例对象的指针 */ Test test = new Test(); /** * 执行第二句代码，声明定义一个int型变量（8种基本数据类型），在栈区直接分配一块内存存储这个变量的值 */ int date = 9; /** * 执行第三句代码，创建一个BirthDate实例bd1,在栈中分配一块内存，存放一个指向堆区实例对象的指针 */ BirthDate bd1 = new BirthDate(13,6,1991); /** * 执行第四句代码，创建一个BirthDate实例bd2,在栈中分配一块内存，存放一个指向堆区实例对象的指针 */ BirthDate bd2 = new BirthDate(30,4,1991); /** * 执行第五句代码，方法test1入栈帧，执行完出栈 */ test.test1(date); /** * 执行第六句代码，方法test2入栈帧，执行完出栈 */ test.test2(bd1); /** * 执行第七句代码，方法test3入栈帧，执行完出栈 */ test.test3(bd2); &#125;&#125; 演示过程一12345671.JVM自动寻找main方法，执行第一句代码，创建一个Test类的实例test， 在栈中分配一块内存，存放一个指向堆区对象的指针110925。2.创建一个int型的变量date，由于是基本类型，直接在栈中存放date对应的值9。3.创建两个BirthDate类的实例bd1、bd2，在栈中分别存放了对应的指针指向各自的对象 ,他们在实例化时调用了有参数的构造方法，因此对象中有自定义初始值。 图解如下： 演示过程二12345671.test1方法入栈帧，以date为参数2.value为局部变量，把value放在栈中，并且把date的值赋值给value3.把123456赋值给value局部变量4.test1方法执行完，value内存被释放，test1方法出栈 演示过程三123456789101.test2方法入栈帧，以实例bd1为参数2.birthDate为局部变量，把birthDate放在栈中，把bd1的引用的值赋值给birthDate， 也就是bd1与birthDate的地址都是指向同一个堆区的实例3.在堆区new了一个对象，并且把这个堆区的指针保存在栈区中birthDate对应的内存空 间，这个时候，bd1与birthDate指向了不同的堆区，那么birthDate的改变，并不会对 bd1造成影响4.test2方法执行完，栈中的birthDate空间被释放，test2方法出栈，但堆区的内存空间 则要等待系统自动回收 演示过程四12345671.test3方法入栈帧，以实例bd2为参数2.birthDate为局部变量，把birthDate放在栈中，把bd2的引用的值赋值给birthDate， 也就是bd2与birthDate的地址都是指向同一个堆区的实例3.调用birthDate的setDay方法，因为birthDate与bd2指向的是同一个对象，也就是bd2调用了setDay方法，所以，也会bd2造成影响4.test3方法执行完，栈中的birthDate空间被释放，test3方法出栈 3.JVM内存分配小结跟着上面四个步骤，走一遍，会发现其实也不会那么复杂，掌握思想就能摸到门路了，我们平时注意区分一下基本数据类型的变量和引用数据类型变量，以下进行了几点概括： 123456789101.局部变量中的基本数据类型的值直接存栈中2.局部变量中的引用数据类型在栈中存的是引用类型的指针（地址）3.栈中的数据与堆中的数据内存回收并不是同步的，栈中的只要方法运行完，就会直接 销毁局部变量，但堆中的对象不一定立即销毁 4.类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中 )。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被 压入栈，方法不使用则不占用内存 干货总结终于把JVM内存分配的分享写完了，一路写下来，确实对内存分配又深入了解了一次。期间参考了以下博客： Java之美[从菜鸟到高手演变]之JVM内存管理及垃圾回收 Java 内存分配全面浅析 Jvm内存模型 通过对JVM内存模型的认识后，下一章将进行JVM垃圾回收机制的探索。]]></content>
      <categories>
        <category>Android性能调优</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>JVM</tag>
        <tag>内存分配</tag>
        <tag>JVM内存模型</tag>
        <tag>java内存分配</tag>
        <tag>内存</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能调优篇之UI布局优化]]></title>
    <url>%2Farchives%2F2017%2F08%2F02%2FAndroid%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87%E4%B9%8BUI%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[开篇废话根据第一篇的规划，趁着周日的空闲时间，认真查阅了UI布局优化的一些知识，在这里总结一下，写这篇文章的最终目的是希望能给从用户最直观的体验部分进行有效的UI优化，使用的方法是从实际操作到原理解说，做到知其然，且知其所以然。 技术详情一、Android UI 渲染简述我们首先需要知道一个大概是生物领域的一个知识点： 12人眼与大脑之间的协作无法感知超过60fps的画面更新。 那么对于这个60fps的值是个什么概念呢？举几个例子说明一下，如果我们自己用手快速翻书，纸张哗哗哗的在眼前略过，那个帧率的值大概是12fps,电影胶卷使用的帧率大概是24fps,因为24fps的值可以使人眼感知的是连续性的运动，其实再大点也是可以，但意味着增加了人工成本，需要更多的帧，所以24帧能够做到最少的费用支出（好像有点跑偏了）。所以，我们app的性能标准就是保证60fps这个值，也就代表每一帧，只有1000/60 = 16ms的时间来处理任务。 Android系统每一次的渲染都是通过底层一个VSYNC信号来触发UI的渲染，间隔时间为16ms,那么我们应该了解为什么需要有UI布局优化这个概念。 我们在使用app的时候，会发现有多的时候，界面会出现卡顿不流畅的情况，是因为当前这个界面UI的处理超过了16ms,则会占用下一个16ms,这样就导致16ms * 2 都是显示的同一帧，也就是我看到的“卡了” 二、UI布局优化实操了解Android的渲染机制后，下面我们该来分析分析我们的app为什么会出现超过16ms的重绘时间的，大致有以下几点原因： 121.布局层次不合理2.布局存在过度绘制 下面针对以上原因，给出相应的解决方案 1.使用Hierarchy Viewer工具检测对于Hierarchy Viewer工具的使用，可以查看我之前的一篇文章： Android性能调优篇之Hierarchy Viewer工具的使用 优化案例： 使用LinearLayout嵌套布局版本(嵌套了一层LinearLayout) 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/chat_author_avatar1&quot; android:layout_width=&quot;@dimen/left_width_height&quot; android:layout_height=&quot;@dimen/left_width_height&quot; android:layout_margin=&quot;@dimen/around_margin&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/up_text&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/down_text&quot;/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 使用Hierarchy Viewer工具查看的结果是： 使用RelativeLayout优化布局为： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/left_image&quot; android:layout_width=&quot;@dimen/left_width_height&quot; android:layout_height=&quot;@dimen/left_width_height&quot; android:layout_margin=&quot;@dimen/around_margin&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;TextView android:id=&quot;@+id/tvUpText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toRightOf=&quot;@id/left_image&quot; android:text=&quot;@string/up_text&quot; /&gt; &lt;TextView android:id=&quot;@+id/tvDownText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/tvUpText&quot; android:layout_toRightOf=&quot;@id/left_image&quot; android:text=&quot;@string/down_text&quot; /&gt;&lt;/RelativeLayout&gt; 然后使用Hierarchy Viewer工具查看结果为: 通过两次的结果截图中的有色灯（三个圈圈分别表示measure 、layout、draw的速度）来看，红色（红色的指示灯能够提供给我们一些依据）的已经没有了。一般我们布局编辑按以下规则进行编码： 12341.尽量多使用 ConstraintLayout、RelativeLayout、LinearLayout2.尽量使用 ConstraintLayout3.在布局的层级相同的情况下，使用 LinearLayout 代替 RelativeLayout4.在布局复杂或者层级过深的时候，使用 RelativeLayout 代替 LinearLayout 使界面层级扁平化，降低层级 另外，关于app界面层级的优化，Android Studio给我们提供了一个很好的工具：Lint,通过Lint工具的分析功能，能够检测出一些布局方面的不足，然后方便我们进行优化定位，至于Lint工具的使用步骤，以后会单独生成一篇博客。这里先引用别人的博客：Improve Your Code with Lint 2.使用include 和merge标签减少复用布局而产生的布局嵌套，使用ViewStub懒加载减少渲染元素布局复用的步骤大致为： 1231.创建一个正常的可用布局layout文件A_layout.xml2.在需要添加复用布局(A_layout.xml)的当前布局内B_layout.xml，使用include标签3.将A_layout.xml的布局文件中的Root View 替换成merge标签，从而减少布局嵌套 第一步：创建一个正常可用的布局layout文件，命名为A_layout.xml 123456789101112131415161718192021&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vetical&quot; &gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;张三&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;李四&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;王五&quot; /&gt;&lt;/LinearLayout&gt; 第二步：使用include标签把复用布局添加到实际需要的布局中（B_layout.xml）去 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;include layout=&quot;@layout/A_layout&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hello_world&quot; /&gt;&lt;/LinearLayout&gt; 第三步：把第一步中的布局文件中的LinearLayout替换成merge标签（当熟悉之后，可以直接创建一个merge标签的布局文件，第三步可以省略） 123456789101112131415161718&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;张三&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;李四&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;王五&quot; /&gt;&lt;/merge&gt; 系统在加载这个布局的时候，会自动忽略merge标签，从而将上述的三个TextView直接加入到第二步中的include标签的位置，而并没有增加布局层级 3.诊断过度绘制，优化过度绘制诊断过度绘制12345678910过度绘制:屏幕上某一像素点在一帧中被重复绘制多次分类（根据层度）：无过度绘制（一个像素只被绘制了一次） （原色）过度绘制x1（一个像素被绘制了两次） （蓝色）过度绘制x2（一个像素被绘制了三次） （绿色）过度绘制x3（一个像素被绘制了四次） （粉色）过度绘制x4+（一个像素被绘制了五次以上） （红色） 接着 我们一起来看一下，如何查看我们的App过度绘制的情况 第一种方案：adb命令行的方式: 123456打开调试GPU过度绘制adb shell setprop debug.hwui.overdraw show关闭调式GPU过度绘制adb shell setprop debug.hwui.overdraw false 第二种方案：我们的Android调试机中的开发者选项中开启【调试GPU过度绘制】 进入我们的调试机器饿开发者选项界面中，往下拉会看到： 点击后，选择【显示过度绘制区域】 如果发现我们的app上深红色的色块比较多，那么可能就要注意了，需要进行优化了。 优化过度绘制1. 移除不必要的background我们首先根据GPU过度绘制定位到需要优化的布局位置： 然后定位到代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/chat_author_avatar1&quot; android:layout_width=&quot;@dimen/left_width_height&quot; android:layout_height=&quot;@dimen/left_width_height&quot; android:layout_margin=&quot;@dimen/around_margin&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/white&quot; android:text=&quot;@string/up_text&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/white&quot; android:text=&quot;@string/down_text&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 我们发现，不居中确实出现了好多次的backgound的配置： 所以移除一些不必要的background 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/chat_author_avatar1&quot; android:layout_width=&quot;@dimen/left_width_height&quot; android:layout_height=&quot;@dimen/left_width_height&quot; android:layout_margin=&quot;@dimen/around_margin&quot; android:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/up_text&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/down_text&quot;/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 运行之后为： 明显有改善了，所以在我们实际生产中，需要非常有耐心的去不断诊断，不断去调试，有些时候我们使用ImageView的时候，可能会给它设置一个background，在代码中，还有可能给它设了一个imageDrawable,从而发生过度绘制的情况，切记切记。解决方案是把背景图和真正加载的图片都通过imageDrawable方法进行设置。 2. clipRect和clipPath方法的妙用clipRect的功能可以理解为在一个大的画布中，用一些大小可变的矩形一个一个来裁切，在某一个矩形内，绘制想要绘制的图形，超出的不进行绘制，当我们的app这样进行写自定义View的时候，可以避免view与view之间的叠加，从而产生同一个像素点被绘制多次的情况，原理就是这样，贴一个Hongyang大神的重写onDraw方法： 12345678910111213141516171819202122@Overrideprotected void onDraw(Canvas canvas)&#123; super.onDraw(canvas); canvas.save(); canvas.translate(20, 120); for (int i = 0; i &lt; mCards.length; i++) &#123; canvas.translate(120, 0); canvas.save(); if (i &lt; mCards.length - 1) &#123; canvas.clipRect(0, 0, 120, mCards[i].getHeight()); &#125; canvas.drawBitmap(mCards[i], 0, 0, null); canvas.restore(); &#125; canvas.restore();&#125; 干货总结文章的内容参考了Hongyang大神的博客：Android UI性能优化实战 识别绘制中的性能问题 关于UI布局优化的内容，其实存在很多细节，更多的情况，还是得依靠我们平时对于UI布局优化的积累与经验去进行优化。再次总结几点经验： 1234567891.将可重复使用的布局通过include标签与merge标签搭配进行使用2.尽量少添加不必要的背景，减少过度绘制3.布局能扁平化的扁平化，尽量不要增加布局层级4.适当的时侯某些控件使用懒加载ViewStub,但需要牢记它的坑5.使用Hierarchy View 工具或者Lint工具来进行app的检测]]></content>
      <categories>
        <category>Android性能调优</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>hierarchy view</tag>
        <tag>UI布局优化</tag>
        <tag>渲染</tag>
        <tag>ViewStub</tag>
        <tag>include</tag>
        <tag>merge</tag>
        <tag>lint</tag>
        <tag>Genymotion</tag>
        <tag>Android device monitor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能调优篇之Hierarchy Viewer工具的使用]]></title>
    <url>%2Farchives%2F2017%2F07%2F31%2FAndroid%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AF%87%E4%B9%8BHierarchy-Viewer%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[开篇废话我们平时在做UI布局优化的时候，时常提起的一个工具Hierarchy Viewer,它提供了一个很直观的可视化界面来观测布局界面的层级，可以检查布局层次结构中每个视图的属性和布局速度。它可以帮助我们查找由视图层次结构导致的性能瓶颈，从而帮助我们简化层次结构并减少过度绘制（Overdraw）的问题 技术详情我们从以下几个步骤来讲述Hierarchy Viewer工具的使用： 1234第一步：开启Hierarchy View的工作界面第二步：检测移动设备（虚拟机）的View Server是否开启第三步：移动设备开启某个需要检测的界面，Hierarchy View 加载该界面视图第四步：工具熟悉 第一步：开启Hierarchy Viewer的工作界面针对Android Studio 2.x版本系列： 在Android Stduio的菜单栏依次点击：1Tools&gt;Android&gt;Android Device Monitor 点击后，稍等一会会弹出一个界面： 选择Hierarchy View之后，我们就能看到Hierarchy View工具的工作界面了： 第二步：检测移动设备（虚拟机）的View Server是否开启当移动设备正确连接PC之后，使用adb指令在命令行里面输入： 1adb shell service call window 3 如果提示adb不是内部指令的话，记得进行配置环境变量，将platform-tools里面的adb.exe路径配置到Path中去（Windows环境，其他系统的类似） 执行后 123若返回值是：Result: Parcel(00000000 00000000 &apos;........&apos;) 说明View Server处于关闭状态。若返回值是：Result: Parcel(00000000 00000001 &apos;........&apos;) 说明View Server处于开启状态。 如果是一台可以打开View Service Android设备（Android开发版手机，模拟器,注意版本要在Android4.1及以上哈）可以用以下命令操作View Server 1234打开View Server命令：adb shell service call window 1 i32 4939关闭View Server命令：adb shell service call window 2 i32 4939 第三步：移动设备开启某个需要检测的界面，Hierarchy View 加载该界面视图当命令行显示了Result: Parcel(00000000 00000001 ‘……..’),重新打开一下Android Device Monitor,然后点击Load view按钮，就能加载界面的一个视图了： 如果点击加载视图按钮没有看到右边的图的话，把Android Device Monitor整个界面先关掉，然后将View Server先关闭，再查看是否关闭，没有关闭，就多运行几次关闭指令 12关闭View Server命令：adb shell service call window 2 i32 4939 然后运行开启View Server,知道开启了View Server,再重新打开Android Device Monitor,依然不行，就重复多次，如果三四次之后还是不行，那问题就另当别论了哈 第四步：工具熟悉123Tree View（中心）：显示视图层次结构。您可以使用鼠标拖动并放大，底部的缩放控件。每个节点表示它的View类名和ID名称。Tree Overview（右上）：为您的应用程序的完整视图层次结构提供鸟瞰图。移动灰色矩形以更改树视图中可见的视口。Layout View（右下角）：显示布局的线框视图。当前所选视图的轮廓为红色，其父视图为浅红色。 三个小圆点, 依次表示Measure, Layout, Draw, 可以理解为对应View的onMeasure, onLayout, onDraw三个方法。 123绿色, 表示该View的此项性能比该View Tree中超过50%的View都要快。黄色, 表示该View的此项性能比该View Tree中超过50%的View都要慢。红色, 表示该View的此项性能是View Tree中最慢的 界面中出现的红色圈圈多了，我们就要注意了： 123Measure红点, 可能是布局中嵌套RelativeLayout, 或是嵌套LinearLayout都使用了weight属性Layout红点, 可能是布局层级太深。Draw红点, 可能是自定义View的绘制有问题, 复杂计算等。 干货总结这篇文章是为了下一篇的UI布局优化做的一个准备，因为，在UI布局优化中，这个工具一般是少不了的，在我们实际生产中，也是非常有用的一个工具，所以，我们需要好好了解这个工具。 本篇内容使用的环境为Windows7 + Android Studio + Genymotion虚拟机 2.3.3,所以如果用Eclipse的小伙伴有点不适用这个，不过，原理差不多，adb指令也是一样，具体得自身去尝试了，毕竟Android Studio工具是google推荐的，属于正宫娘娘 此篇中暂时没有提及真机版移动设备使用Hierarchy View 这个工具，因为google处于安全层面的考虑，真机无法开启View Server这个服务，不过还是有方法可以使用，只是稍微麻烦一点，我这里就不进行赘述了。]]></content>
      <categories>
        <category>Android性能调优</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>hierarchy view</tag>
        <tag>UI布局优化</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进阶之学习规划]]></title>
    <url>%2Farchives%2F2017%2F07%2F29%2FAndroid%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[开篇废话2017年7月29日，个人花了两天时间，使用Hexo + Github搭建了一个自己的博客，踩了不少坑，但最终依靠网络上资源成功搭建好了，也买了一个自己使用的一个域名，准备在Android进阶之路上好好学习，好好分享。 本来想着第一篇博客想通过自己使用Hexo + Github搭建博客的踩坑经历来讲述一下如何一步一步搭建自己的博客，但思前想后，还是觉得算了，毕竟现如今在网络上的那些资源应该足够让自己成功搭建好一个博客，再说，这也只是一个工具，不成功，换一种技术就好。 好了，其他的不多说了，这是我在简书，也是自己的博客上发布的第一篇文章（以前都是使用的博客园），希望对自己来说，可以是一个新的起点，也希望自己在Android进阶这条路上能够遇到更多的志同道合的朋友，一起入坑，一起畅聊人生。 学习规划根据目前自身对于Android应用开发知识的掌握程度，为自己制定了一个学习规划，如果这个规划能够与某些朋友存在共鸣，我们可以一起交流交流人生。 （一）Android性能调优 （二）Android基础知识回顾 （三）Android系统源码的学习 （四）Android的IPC机制 （五）Android的线程和线程池 （六）Android NDK编程的深入学习（C++） （七）Android的消息机制 （八）数据结构的学习（Java实现版） （九）Android网络编程相关的底层原理（TCP/IP） （十）Android官方语言Kotlin语言的学习 （十一）设计模式 规划解读对于上面列举的十大规划，可以说每一个内容，都需要花费大量的时间去查阅资料，去认真对待。需要指明的是，他们的顺序并不能代表重要性的顺序，每一个内容都非常重要，在之后的博客中，也不会按这个顺序去一一学习，会结合个人的工作内容以及对于某一个内容的认知程度去学习。首先把这些大的方向指定，然后就是为之付出，要知道我们前面的征途是星辰大海。 干货总结搭建个人博客我参考了以下文章： 基于Hexo+Github Pages的博客搭建 Windows下GitHub + Hexo搭建个人博客 当中要是存在问题，可以留言，会根据个人经验进行解惑，但还是希望自己能够通过不断摸索去扫清障碍，那样会更加的有继续学下去的激情。附上我的个人博客地址:senduo’s blog 以及我的简书地址：欧阳的简书 对于以上Android进阶的规划，是根据个人目前掌握的Android相关知识进行的规划，是自己脑海中一直挂念着的一些知识点，想通过这次规划来提升自己对这些领域的更深层次的理解，相信，有很多内容大家都可以一起讨论，或者缺少哪一块的内容，可以直接留言。 让我们秉着真诚学习的心态，走进Android进阶之门。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>进阶</tag>
        <tag>性能调优</tag>
        <tag>IPC</tag>
        <tag>NDK</tag>
        <tag>设计模式</tag>
        <tag>Java数据结构</tag>
      </tags>
  </entry>
</search>